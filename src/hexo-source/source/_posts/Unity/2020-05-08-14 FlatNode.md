---
title: Unity æŠ€èƒ½ç¼–è¾‘å™¨ä¸æ‰å¹³æ•°æ®ç¼“å­˜è®¾è®¡
date: 2020/05/08
categories: [æŠ€æœ¯æ–‡ç« , Unityå¼€å‘]
tags: [Unity, æŠ€èƒ½ç¼–è¾‘å™¨, FlatBuffers, æ•°æ®ç¼“å­˜, æ€§èƒ½ä¼˜åŒ–, GamePlay]
---

# Unity æŠ€èƒ½ç¼–è¾‘å™¨ä¸æ‰å¹³æ•°æ®ç¼“å­˜è®¾è®¡

> æœ¬æ–‡ä»‹ç»å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½çš„æŠ€èƒ½ç¼–è¾‘å™¨ï¼Œä½¿ç”¨æ‰å¹³æ•°æ®ç»“æ„ï¼ˆFlatBuffersï¼‰ç¼“å­˜æŠ€èƒ½æ•°æ®ï¼Œå®ç°å¿«é€ŸåŠ è½½å’Œè¿è¡Œæ—¶é«˜æ•ˆè®¿é—®ã€‚

## ä¸€ã€è®¾è®¡æ¦‚è¿°

### 1.1 ä¸ºä»€ä¹ˆä½¿ç”¨æ‰å¹³æ•°æ®

| æ•°æ®ç»“æ„ | åŠ è½½é€Ÿåº¦ | å†…å­˜å ç”¨ | åºåˆ—åŒ– | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|--------|---------|
| **ç±»å¯¹è±¡** | æ…¢ | å¤§ï¼ˆå¯¹è±¡å¤´ï¼‰ | ç®€å• | å¼€å‘æœŸ |
| **ScriptableObject** | ä¸­ | ä¸­ | å†…ç½® | Unity é…ç½® |
| **JSON** | æ…¢ | å¤§ | ç®€å• | ç½‘ç»œä¼ è¾“ |
| **FlatBuffers** | å¿« | å° | éœ€å·¥å…· | å¤§é‡æ•°æ® |
| **è‡ªå®šä¹‰äºŒè¿›åˆ¶** | æœ€å¿« | æœ€å° | è‡ªå®šä¹‰ | è¿½æ±‚æ€§èƒ½ |

### 1.2 æŠ€èƒ½ç¼–è¾‘å™¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æŠ€èƒ½ç¼–è¾‘å™¨æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      ç¼–è¾‘      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚ å¯è§†åŒ–ç¼–è¾‘   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  æŠ€èƒ½é…ç½®æ•°æ®  â”‚            â”‚
â”‚   â”‚   ç•Œé¢      â”‚               â”‚ (Scriptable)  â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                                â”‚                     â”‚
â”‚         â”‚ å¯¼å‡º                          â”‚ åºåˆ—åŒ–               â”‚
â”‚         â–¼                                â–¼                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚ FlatBuffers  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ äºŒè¿›åˆ¶æ•°æ®    â”‚            â”‚
â”‚   â”‚  .bytes æ–‡ä»¶  â”‚     åŠ è½½         â”‚  (.bytes)    â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚         â”‚                                                     â”‚
â”‚         â”‚ è¿è¡Œæ—¶åŠ è½½                                           â”‚
â”‚         â–¼                                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      è¯»å–      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚  æŠ€èƒ½ç³»ç»Ÿ    â”‚ <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  ç¼“å­˜ç®¡ç†å™¨  â”‚            â”‚
â”‚   â”‚             â”‚                 â”‚              â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€æŠ€èƒ½æ•°æ®ç»“æ„è®¾è®¡

### 2.1 æŠ€èƒ½é…ç½®ç±»

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// æŠ€èƒ½é…ç½®æ•°æ®
/// </summary>
[CreateAssetMenu(fileName = "NewSkill", menuName = "Game/Skill Config")]
public class SkillConfig : ScriptableObject
{
    [Header("åŸºç¡€ä¿¡æ¯")]
    public int skillId;
    public string skillName = "æ–°æŠ€èƒ½";
    public SkillType skillType = SkillType.Active;
    public Sprite icon;

    [Header("å±æ€§")]
    [Range(0, 100)]
    public int damage = 10;
    [Range(0, 500)]
    public float range = 5f;
    [Range(0, 60)]
    public float cooldown = 10f;

    [Header("æ•ˆæœ")]
    public SkillEffect[] effects;
    public SkillCondition[] conditions;

    [Header("åŠ¨ç”»")]
    public string animationTrigger;
    public float animationDuration = 1f;

    [Header("ç¼–è¾‘å™¨ä¿¡æ¯")]
    [System.NonSerialized]
    public string editorColor = "#FFFFFF";
}

/// <summary>
/// æŠ€èƒ½ç±»å‹
/// </summary>
public enum SkillType
{
    Passive,    // è¢«åŠ¨æŠ€èƒ½
    Active,     // ä¸»åŠ¨æŠ€èƒ½
    Channel,    // å¼•å¯¼æŠ€èƒ½
    Toggle      // åˆ‡æ¢æŠ€èƒ½
}

/// <summary>
/// æŠ€èƒ½æ•ˆæœ
/// </summary>
[System.Serializable]
public class SkillEffect
{
    public EffectType type;
    public float value;
    public float duration;
    public string targetTag;
}

public enum EffectType
{
    Damage,         // ä¼¤å®³
    Heal,           // æ²»ç–—
    Buff,           // å¢ç›Š
    Debuff,         // å‡ç›Š
    Knockback,      // å‡»é€€
    Stun            // çœ©æ™•
}

/// <summary>
/// æŠ€èƒ½é‡Šæ”¾æ¡ä»¶
/// </summary>
[System.Serializable]
public class SkillCondition
{
    public ConditionType type;
    public float minValue;
    public float maxValue;
}

public enum ConditionType
{
    HealthGreaterThan,      // ç”Ÿå‘½å€¼å¤§äº
    HealthLessThan,         // ç”Ÿå‘½å€¼å°äº
    ManaGreaterThan,        // é­”æ³•å€¼å¤§äº
    TargetInRange,          // ç›®æ ‡åœ¨èŒƒå›´å†…
    CooldownReady           // å†·å´å°±ç»ª
}
```

### 2.2 æ‰å¹³æ•°æ®ç»“æ„

```csharp
/// <summary>
/// æŠ€èƒ½æ‰å¹³æ•°æ® - è¿è¡Œæ—¶ä½¿ç”¨çš„ç´§å‡‘ç»“æ„
/// </summary>
public struct SkillFlatData
{
    // åŸºç¡€ä¿¡æ¯ (12 bytes)
    public int skillId;
    public short skillType;
    public short flags;      // ä½æ ‡è®°ï¼šisChanneling, isToggle, etc.

    // å±æ€§ (16 bytes)
    public short damage;
    public short range;
    public short cooldown;   // ä»¥ç§’ä¸ºå•ä½ * 100
    public short animationId;

    // æ•ˆæœæ•°æ®åç§» (8 bytes)
    public int effectsOffset;   // åœ¨ effects æ•°ç»„ä¸­çš„åç§»
    public short effectCount;
    public short padding;

    // æ€»å¤§å°: 36 bytes
}

/// <summary>
/// æŠ€èƒ½æ•ˆæœæ‰å¹³æ•°æ®
/// </summary>
public struct SkillEffectFlatData
{
    public short effectType;
    public short value;      // å€¼ * 100
    public short duration;   // ä»¥ç§’ä¸ºå•ä½ * 100
    public short targetTagId;

    // æ€»å¤§å°: 8 bytes
}

/// <summary>
/// æŠ€èƒ½æ•°æ®åº“ - å­˜å‚¨æ‰€æœ‰æ‰å¹³æ•°æ®
/// </summary>
public class SkillDatabase
{
    private SkillFlatData[] skills;
    private SkillEffectFlatData[] effects;
    private Dictionary<int, int> skillIdToIndex;

    public SkillDatabase(byte[] flatData)
    {
        LoadFromFlatBuffer(flatData);
    }

    public ref SkillFlatData GetSkill(int skillId)
    {
        if (skillIdToIndex.TryGetValue(skillId, out int index))
        {
            return ref skills[index];
        }
        throw new System.KeyNotFoundException($"Skill {skillId} not found");
    }

    public Span<SkillEffectFlatData> GetEffects(SkillFlatData skill)
    {
        return effects.AsSpan(skill.effectsOffset, skill.effectCount);
    }

    private void LoadFromFlatBuffer(byte[] data)
    {
        // è§£ææ‰å¹³æ•°æ®
        // å®é™…å®ç°æ ¹æ®åºåˆ—åŒ–æ ¼å¼è€Œå®š
    }
}
```

---

## ä¸‰ã€ç¼–è¾‘å™¨å®ç°

### 3.1 æŠ€èƒ½ç¼–è¾‘å™¨çª—å£

```csharp
using UnityEngine;
using UnityEditor;
using System.Linq;

[CustomEditor(typeof(SkillConfig))]
public class SkillConfigEditor : Editor
{
    private SkillConfig skill;
    private SerializedObject serializedSkill;
    private SerializedProperty effectsProperty;
    private SerializedProperty conditionsProperty;

    private GUIStyle headerStyle;
    private GUIStyle boxStyle;

    void OnEnable()
    {
        skill = (SkillConfig)target;
        serializedSkill = new SerializedObject(target);
        effectsProperty = serializedSkill.FindProperty("effects");
        conditionsProperty = serializedSkill.FindProperty("conditions");

        // åˆå§‹åŒ–æ ·å¼
        InitStyles();
    }

    private void InitStyles()
    {
        headerStyle = new GUIStyle(EditorStyles.boldLabel)
        {
            fontSize = 14,
            fontStyle = FontStyle.Bold
        };

        boxStyle = new GUIStyle(EditorStyles.helpBox)
        {
            padding = new RectOffset(10, 10, 10, 10)
        };
    }

    public override void OnInspectorGUI()
    {
        serializedSkill.Update();

        // ç»˜åˆ¶å¤´éƒ¨ä¿¡æ¯
        DrawHeader();

        EditorGUILayout.Space();

        // åŸºç¡€ä¿¡æ¯
        DrawBasicInfo();

        EditorGUILayout.Space();

        // å±æ€§è®¾ç½®
        DrawProperties();

        EditorGUILayout.Space();

        // æ•ˆæœåˆ—è¡¨
        DrawEffects();

        EditorGUILayout.Space();

        // æ¡ä»¶åˆ—è¡¨
        DrawConditions();

        EditorGUILayout.Space();

        // é¢„è§ˆ
        DrawPreview();

        serializedSkill.ApplyModifiedProperties();
    }

    private void DrawHeader()
    {
        // æŠ€èƒ½å›¾æ ‡å’Œåç§°
        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.ObjectField(skill.icon, typeof(Sprite), false, GUILayout.Width(64));
        EditorGUILayout.BeginVertical();
        EditorGUILayout.LabelField($"ID: {skill.skillId}", EditorStyles.boldLabel);
        EditorGUILayout.LabelField(skill.skillName, EditorStyles.largeLabel);
        EditorGUILayout.EndVertical();
        EditorGUILayout.EndHorizontal();
    }

    private void DrawBasicInfo()
    {
        EditorGUILayout.LabelField("åŸºç¡€ä¿¡æ¯", headerStyle);
        EditorGUILayout.BeginVertical(boxStyle);
        EditorGUILayout.PropertyField(serializedSkill.FindProperty("skillId"));
        EditorGUILayout.PropertyField(serializedSkill.FindProperty("skillName"));
        EditorGUILayout.PropertyField(serializedSkill.FindProperty("skillType"));
        EditorGUILayout.PropertyField(serializedSkill.FindProperty("icon"));
        EditorGUILayout.EndVertical();
    }

    private void DrawProperties()
    {
        EditorGUILayout.LabelField("å±æ€§è®¾ç½®", headerStyle);
        EditorGUILayout.BeginVertical(boxStyle);

        var damageProp = serializedSkill.FindProperty("damage");
        var rangeProp = serializedSkill.FindProperty("range");
        var cooldownProp = serializedSkill.FindProperty("cooldown");

        EditorGUILayout.PropertyField(damageProp);
        EditorGUILayout.PropertyField(rangeProp);
        EditorGUILayout.PropertyField(cooldownProp);

        // è®¡ç®—æˆ˜æ–—åŠ›
        int combatPower = skill.damage * 2 + (int)(skill.range * 5);
        EditorGUILayout.HelpBox($"æˆ˜æ–—åŠ›æŒ‡æ•°: {combatPower}", MessageType.Info);

        EditorGUILayout.EndVertical();
    }

    private void DrawEffects()
    {
        EditorGUILayout.LabelField("æŠ€èƒ½æ•ˆæœ", headerStyle);
        EditorGUILayout.BeginVertical(boxStyle);

        EditorGUILayout.PropertyField(effectsProperty, true);

        if (effectsProperty.arraySize > 0)
        {
            EditorGUILayout.Space();
            if (GUILayout.Button("æ¸…ç©ºæ‰€æœ‰æ•ˆæœ"))
            {
                effectsProperty.ClearArray();
            }
        }

        EditorGUILayout.EndVertical();
    }

    private void DrawConditions()
    {
        EditorGUILayout.LabelField("é‡Šæ”¾æ¡ä»¶", headerStyle);
        EditorGUILayout.BeginVertical(boxStyle);
        EditorGUILayout.PropertyField(conditionsProperty, true);
        EditorGUILayout.EndVertical();
    }

    private void DrawPreview()
    {
        EditorGUILayout.LabelField("é¢„è§ˆ", headerStyle);
        EditorGUILayout.BeginVertical(boxStyle);

        // ç»˜åˆ¶æŠ€èƒ½èŒƒå›´é¢„è§ˆ
        DrawRangePreview();

        EditorGUILayout.EndVertical();
    }

    private void DrawRangePreview()
    {
        Rect rect = EditorGUILayout.GetControlRect(false, 200);
        GUI.Box(rect, "èŒƒå›´é¢„è§ˆ");

        // ç»˜åˆ¶èŒƒå›´åœ†
        Vector2 center = new Vector2(rect.x + rect.width / 2, rect.y + rect.height / 2);
        float maxRadius = Mathf.Min(rect.width, rect.height) / 2 - 10;
        float displayRadius = (skill.range / 10f) * maxRadius;

        Handles.BeginGUI();
        Handles.color = new Color(0, 1, 0, 0.5f);
        Handles.DrawWireDisc(center, Vector3.forward, displayRadius);
        Handles.color = new Color(1, 0, 0, 0.3f);
        Handles.DrawSolidDisc(center, Vector3.forward, displayRadius * 0.3f);
        Handles.EndGUI();

        // æ˜¾ç¤ºèŒƒå›´æ–‡æœ¬
        GUI.Label(new Rect(center.x - 50, center.y - 10, 100, 20),
            $"èŒƒå›´: {skill.range}m", EditorStyles.centeredGreyMiniLabel);
    }
}
```

### 3.2 æŠ€èƒ½ç®¡ç†å™¨çª—å£

```csharp
using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;

public class SkillManagerWindow : EditorWindow
{
    private Vector2 scrollPosition;
    private SkillConfig selectedSkill;
    private string searchFilter = "";

    [MenuItem("Tools/Skill Manager")]
    public static void ShowWindow()
    {
        var window = GetWindow<SkillManagerWindow>();
        window.titleContent = new GUIContent("æŠ€èƒ½ç®¡ç†å™¨");
        window.Show();
    }

    void OnGUI()
    {
        // å·¥å…·æ 
        DrawToolbar();

        EditorGUILayout.Space();

        // åˆ†æ å¸ƒå±€
        EditorGUILayout.BeginHorizontal();

        // å·¦ä¾§ï¼šæŠ€èƒ½åˆ—è¡¨
        DrawSkillList();

        // å³ä¾§ï¼šæŠ€èƒ½è¯¦æƒ…
        if (selectedSkill != null)
        {
            DrawSkillDetail();
        }

        EditorGUILayout.EndHorizontal();
    }

    private void DrawToolbar()
    {
        EditorGUILayout.BeginHorizontal(EditorStyles.toolbar);

        // æœç´¢æ¡†
        searchFilter = EditorGUILayout.TextField("æœç´¢: ", searchFilter, EditorStyles.toolbarSearchField);

        GUILayout.FlexibleSpace();

        // åˆ›å»ºæ–°æŠ€èƒ½æŒ‰é’®
        if (GUILayout.Button("åˆ›å»ºæŠ€èƒ½", EditorStyles.toolbarButton, GUILayout.Width(80)))
        {
            CreateNewSkill();
        }

        // åˆ·æ–°æŒ‰é’®
        if (GUILayout.Button("åˆ·æ–°", EditorStyles.toolbarButton, GUILayout.Width(60)))
        {
            AssetDatabase.Refresh();
        }

        // å¯¼å‡ºæ‰€æœ‰æŒ‰é’®
        if (GUILayout.Button("å¯¼å‡º Flat", EditorStyles.toolbarButton, GUILayout.Width(80)))
        {
            ExportAllToFlatBuffer();
        }

        EditorGUILayout.EndHorizontal();
    }

    private void DrawSkillList()
    {
        EditorGUILayout.BeginVertical(GUILayout.Width(250));

        EditorGUILayout.LabelField("æŠ€èƒ½åˆ—è¡¨", EditorStyles.boldLabel);
        scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

        // æŸ¥æ‰¾æ‰€æœ‰æŠ€èƒ½é…ç½®
        var skills = AssetDatabase.FindAssets("t:SkillConfig")
            .Select(AssetDatabase.GUIDToAssetPath)
            .Select(AssetDatabase.LoadAssetAtPath<SkillConfig>)
            .Where(s => s != null)
            .ToList();

        foreach (var skill in skills)
        {
            // æœç´¢è¿‡æ»¤
            if (!string.IsNullOrEmpty(searchFilter))
            {
                if (!skill.skillName.ToLower().Contains(searchFilter.ToLower()) &&
                    !skill.skillId.ToString().Contains(searchFilter))
                {
                    continue;
                }
            }

            // ç»˜åˆ¶æŠ€èƒ½é¡¹
            bool isSelected = selectedSkill == skill;
            if (DrawSkillListItem(skill, isSelected))
            {
                selectedSkill = skill;
            }
        }

        EditorGUILayout.EndScrollView();
        EditorGUILayout.EndVertical();
    }

    private bool DrawSkillListItem(SkillConfig skill, bool isSelected)
    {
        EditorGUILayout.BeginHorizontal(isSelected ? EditorStyles.toolbarButton : GUIStyle.none);

        // æŠ€èƒ½å›¾æ ‡
        if (skill.icon != null)
        {
            Texture iconTexture = skill.icon.texture;
            if (iconTexture != null)
            {
                GUILayout.Label(iconTexture, GUILayout.Width(32), GUILayout.Height(32));
            }
        }
        else
        {
            GUILayout.Box(GUIContent.none, GUILayout.Width(32), GUILayout.Height(32));
        }

        // æŠ€èƒ½åç§°å’ŒID
        EditorGUILayout.BeginVertical();
        EditorGUILayout.LabelField(skill.skillName, EditorStyles.boldLabel);
        EditorGUILayout.LabelField($"ID: {skill.skillId}", EditorStyles.miniLabel);
        EditorGUILayout.EndVertical();

        EditorGUILayout.EndHorizontal();

        return GUILayout.Button("", GUIStyle.none, GUILayout.Height(1));
    }

    private void DrawSkillDetail()
    {
        EditorGUILayout.BeginVertical();

        // æŠ€èƒ½æ ‡é¢˜
        EditorGUILayout.LabelField(selectedSkill.skillName, EditorStyles.largeLabel);
        EditorGUILayout.Space();

        // ä½¿ç”¨è‡ªå®šä¹‰ç¼–è¾‘å™¨
        Editor editor = Editor.CreateEditor(selectedSkill);
        editor.OnInspectorGUI();
        Object.DestroyImmediate(editor);

        EditorGUILayout.Space();

        // æ“ä½œæŒ‰é’®
        DrawSkillActions();

        EditorGUILayout.EndVertical();
    }

    private void DrawSkillActions()
    {
        EditorGUILayout.BeginHorizontal();

        if (GUILayout.Button("ä¿å­˜"))
        {
            EditorUtility.SetDirty(selectedSkill);
            AssetDatabase.SaveAssets();
        }

        if (GUILayout.Button("å¯¼å‡º Flat"))
        {
            ExportToFlatBuffer(selectedSkill);
        }

        if (GUILayout.Button("åˆ é™¤"))
        {
            if (EditorUtility.DisplayDialog("ç¡®è®¤", "ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæŠ€èƒ½å—ï¼Ÿ", "ç¡®å®š", "å–æ¶ˆ"))
            {
                string path = AssetDatabase.GetAssetPath(selectedSkill);
                AssetDatabase.DeleteAsset(path);
                selectedSkill = null;
            }
        }

        EditorGUILayout.EndHorizontal();
    }

    private void CreateNewSkill()
    {
        string path = EditorUtility.SaveFilePanelInProject(
            "åˆ›å»ºæ–°æŠ€èƒ½",
            "Assets/Resources/Skills",
            "asset",
            "è¯·é€‰æ‹©ä¿å­˜ä½ç½®"
        );

        if (!string.IsNullOrEmpty(path))
        {
            // ç¡®ä¿ .asset æ‰©å±•å
            if (!path.EndsWith(".asset"))
            {
                path += ".asset";
            }

            SkillConfig newSkill = ScriptableObject.CreateInstance<SkillConfig>();
            newSkill.skillId = Random.Range(1000, 9999);
            newSkill.skillName = "æ–°æŠ€èƒ½";

            AssetDatabase.CreateAsset(newSkill, path);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();

            selectedSkill = newSkill;
        }
    }
}
```

---

## å››ã€FlatBuffers åºåˆ—åŒ–

### 4.1 å®šä¹‰ FlatBuffers Schema

```flatbuffers
// Skill.fbs

namespace Game;

enum SkillType : byte {
    Passive = 0,
    Active = 1,
    Channel = 2,
    Toggle = 3
}

enum EffectType : byte {
    Damage = 0,
    Heal = 1,
    Buff = 2,
    Debuff = 3,
    Knockback = 4,
    Stun = 5
}

table SkillEffect {
    effectType: EffectType;
    value: float;
    duration: float;
    targetTag: string;
}

table SkillCondition {
    conditionType: string;
    minValue: float;
    maxValue: float;
}

table Skill {
    id: int;
    name: string;
    type: SkillType;
    damage: int;
    range: float;
    cooldown: float;
    effects: [SkillEffect];
    conditions: [SkillCondition];
    animationTrigger: string;
    animationDuration: float;
}

root_type Skill;
```

### 4.2 åºåˆ—åŒ–/ååºåˆ—åŒ–

```csharp
using FlatBuffers;
using Game;

public static class SkillFlatBuffersSerializer
{
    /// <summary>
    /// å°† SkillConfig åºåˆ—åŒ–ä¸º FlatBuffers å­—èŠ‚æ•°ç»„
    /// </summary>
    public static byte[] Serialize(SkillConfig skill)
    {
        FlatBufferBuilder builder = new FlatBufferBuilder(1024);

        // åºåˆ—åŒ–æ•ˆæœåˆ—è¡¨
        VectorOffset effectsOffset = default;
        if (skill.effects != null && skill.effects.Length > 0)
        {
            var effectOffsets = new Offset<SkillEffect>[skill.effects.Length];
            for (int i = skill.effects.Length - 1; i >= 0; i--)
            {
                var effect = skill.effects[i];
                var targetTagOffset = builder.CreateString(effect.targetTag ?? "");

                SkillEffect.StartSkillEffect(builder);
                SkillEffect.AddEffectType((EffectType)effect.type);
                SkillEffect.AddValue(effect.value);
                SkillEffect.AddDuration(effect.duration);
                SkillEffect.AddTargetTag(targetTagOffset);
                effectOffsets[i] = SkillEffect.EndSkillEffect(builder);
            }

            var effectsVectorOffset = builder.CreateVectorOfTables(effectOffsets);
            Skill.StartEffectsVector(builder, skill.effects.Length);
            effectsOffset = builder.EndVector();
        }

        // åºåˆ—åŒ–æ¡ä»¶åˆ—è¡¨
        VectorOffset conditionsOffset = default;
        if (skill.conditions != null && skill.conditions.Length > 0)
        {
            var conditionOffsets = new Offset<SkillCondition>[skill.conditions.Length];
            for (int i = skill.conditions.Length - 1; i >= 0; i--)
            {
                var condition = skill.conditions[i];
                var typeOffset = builder.CreateString(condition.type.ToString());

                SkillConditionStart(builder);
                SkillConditionAddConditionType(typeOffset);
                SkillConditionAddMinValue(condition.minValue);
                SkillConditionAddMaxValue(condition.maxValue);
                conditionOffsets[i] = SkillConditionEnd(builder);
            }

            conditionsOffset = builder.CreateVectorOfTables(conditionOffsets);
        }

        // åºåˆ—åŒ–æŠ€èƒ½åŸºæœ¬ä¿¡æ¯
        var nameOffset = builder.CreateString(skill.skillName);
        var animTriggerOffset = builder.CreateString(skill.animationTrigger ?? "");

        SkillStart(builder);
        SkillAddId(builder, skill.skillId);
        SkillAddName(builder, nameOffset);
        SkillAddType(builder, (SkillType)skill.skillType);
        SkillAddDamage(builder, skill.damage);
        SkillAddRange(builder, skill.range);
        SkillAddCooldown(builder, skill.cooldown);
        SkillAddAnimationTrigger(builder, animTriggerOffset);
        SkillAddAnimationDuration(builder, skill.animationDuration);

        if (effectsOffset.Value != 0)
        {
            SkillAddEffects(builder, effectsOffset.Value);
        }

        if (conditionsOffset.Value != 0)
        {
            SkillAddConditions(builder, conditionsOffset.Value);
        }

        var skillOffset = SkillEnd(builder);
        builder.Finish(skillOffset.Value);

        return builder.SizedByteArray();
    }

    /// <summary>
    /// ä» FlatBuffers å­—èŠ‚æ•°ç»„ååºåˆ—åŒ–ä¸º SkillConfig
    /// </summary>
    public static SkillConfig Deserialize(byte[] data)
    {
        var buf = new ByteBuffer(data);
        var skill = Skill.GetRootAsSkill(buf);

        var config = ScriptableObject.CreateInstance<SkillConfig>();
        config.skillId = skill.Id;
        config.skillName = skill.Name;
        config.skillType = (SkillType)skill.Type;
        config.damage = skill.Damage;
        config.range = skill.Range;
        config.cooldown = skill.Cooldown;
        config.animationTrigger = skill.AnimationTrigger;
        config.animationDuration = skill.AnimationDuration;

        // ååºåˆ—åŒ–æ•ˆæœ
        if (skill.EffectsLength > 0)
        {
            config.effects = new SkillEffect[skill.EffectsLength];
            for (int i = 0; i < skill.EffectsLength; i++)
            {
                var effectData = skill.Effects(i).Value;
                config.effects[i] = new SkillEffect
                {
                    type = (EffectType)effectData.EffectType,
                    value = effectData.Value,
                    duration = effectData.Duration,
                    targetTag = effectData.TargetTag
                };
            }
        }

        // ååºåˆ—åŒ–æ¡ä»¶
        if (skill.ConditionsLength > 0)
        {
            config.conditions = new SkillCondition[skill.ConditionsLength];
            for (int i = 0; i < skill.ConditionsLength; i++)
            {
                var conditionData = skill.Conditions(i).Value;
                config.conditions[i] = new SkillCondition
                {
                    type = (ConditionType)System.Enum.Parse(typeof(ConditionType), conditionData.ConditionType),
                    minValue = conditionData.MinValue,
                    maxValue = conditionData.MaxValue
                };
            }
        }

        return config;
    }
}
```

### 4.3 å¯¼å‡ºåŠŸèƒ½

```csharp
public partial class SkillManagerWindow
{
    private void ExportToFlatBuffer(SkillConfig skill)
    {
        if (skill == null) return;

        byte[] data = SkillFlatBuffersSerializer.Serialize(skill);

        // ä¿å­˜åˆ°æ–‡ä»¶
        string path = EditorUtility.SaveFilePanel(
            "å¯¼å‡ºæŠ€èƒ½æ•°æ®",
            Application.dataPath,
            "bytes"
        );

        if (!string.IsNullOrEmpty(path))
        {
            File.WriteAllBytes(path, data);
            Debug.Log($"æŠ€èƒ½å·²å¯¼å‡ºåˆ°: {path}");
        }
    }

    private void ExportAllToFlatBuffer()
    {
        // æŸ¥æ‰¾æ‰€æœ‰æŠ€èƒ½
        var skills = AssetDatabase.FindAssets("t:SkillConfig")
            .Select(AssetDatabase.GUIDToAssetPath)
            .Select(AssetDatabase.LoadAssetAtPath<SkillConfig>)
            .Where(s => s != null)
            .OrderBy(s => s.skillId)
            .ToArray();

        if (skills.Length == 0)
        {
            EditorUtility.DisplayDialog("æç¤º", "æ²¡æœ‰æ‰¾åˆ°æŠ€èƒ½é…ç½®", "ç¡®å®š");
            return;
        }

        // æ„å»ºåŒ…å«æ‰€æœ‰æŠ€èƒ½çš„ FlatBuffer
        FlatBufferBuilder builder = new FlatBufferBuilder(4096);

        var skillOffsets = new Offset<Game.Skill>[skills.Length];
        for (int i = skills.Length - 1; i >= 0; i--)
        {
            var skillData = ConvertToFlatBufferSkill(builder, skills[i]);
            skillOffsets[i] = skillData.Offset;
        }

        var skillsVector = builder.CreateVectorOfTables(skillOffsets);

        // åˆ›å»ºæŠ€èƒ½é›†
        var skillSetName = builder.CreateString("AllSkills");
        SkillSetStart(builder);
        SkillSetAddName(builder, skillSetName);
        SkillSetAddSkills(builder, skillsVector);
        var skillSetOffset = SkillSetEnd(builder);

        builder.Finish(skillSetOffset.Value);

        // ä¿å­˜æ–‡ä»¶
        string path = EditorUtility.SaveFilePanelInProject(
            "å¯¼å‡ºæŠ€èƒ½æ•°æ®",
            "Assets/Resources",
            "bytes",
            "è¯·é€‰æ‹©ä¿å­˜ä½ç½®"
        );

        if (!string.IsNullOrEmpty(path))
        {
            if (!path.EndsWith(".bytes"))
            {
                path += ".bytes";
            }

            File.WriteAllBytes(path, builder.SizedByteArray());
            AssetDatabase.Refresh();
            Debug.Log($"å·²å¯¼å‡º {skills.Length} ä¸ªæŠ€èƒ½åˆ°: {path}");
        }
    }

    private Game.Skill ConvertToFlatBufferSkill(FlatBufferBuilder builder, SkillConfig config)
    {
        // è½¬æ¢é€»è¾‘ï¼ˆä¸åºåˆ—åŒ–éƒ¨åˆ†ç±»ä¼¼ï¼‰
        // è¿™é‡Œçœç•¥è¯¦ç»†å®ç°
        return default;
    }
}
```

---

## äº”ã€è¿è¡Œæ—¶åŠ è½½

### 5.1 æŠ€èƒ½ç¼“å­˜ç®¡ç†å™¨

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// æŠ€èƒ½ç¼“å­˜ç®¡ç†å™¨ - å•ä¾‹
/// </summary>
public class SkillCacheManager : MonoBehaviour
{
    private static SkillCacheManager instance;
    public static SkillCacheManager Instance => instance;

    // æŠ€èƒ½æ•°æ®åº“
    private SkillDatabase skillDatabase;

    // è¿è¡Œæ—¶ç¼“å­˜
    private Dictionary<int, SkillRuntimeData> skillCache = new Dictionary<int, SkillRuntimeData>();

    [Header("åŠ è½½è®¾ç½®")]
    public string skillDataPath = "Skills/skills.bytes";
    public bool loadOnAwake = true;

    void Awake()
    {
        if (instance == null)
        {
            instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if (loadOnAwake)
        {
            LoadAllSkills();
        }
    }

    /// <summary>
    /// åŠ è½½æ‰€æœ‰æŠ€èƒ½æ•°æ®
    /// </summary>
    public void LoadAllSkills()
    {
        TextAsset asset = Resources.Load<TextAsset>(skillDataPath.Replace(".bytes", ""));
        if (asset == null)
        {
            Debug.LogError($"æŠ€èƒ½æ•°æ®æ–‡ä»¶æœªæ‰¾åˆ°: {skillDataPath}");
            return;
        }

        byte[] data = System.Text.Encoding.UTF8.GetBytes(asset.text);
        skillDatabase = new SkillDatabase(data);

        Debug.Log($"å·²åŠ è½½ {skillDatabase.Count} ä¸ªæŠ€èƒ½");
    }

    /// <summary>
    /// è·å–æŠ€èƒ½è¿è¡Œæ—¶æ•°æ®
    /// </summary>
    public SkillRuntimeData GetSkill(int skillId)
    {
        // æ£€æŸ¥ç¼“å­˜
        if (skillCache.TryGetValue(skillId, out SkillRuntimeData data))
        {
            return data;
        }

        // ä»æ•°æ®åº“åŠ è½½
        if (skillDatabase != null)
        {
            ref var flatData = ref skillDatabase.GetSkill(skillId);

            // åˆ›å»ºè¿è¡Œæ—¶æ•°æ®
            data = new SkillRuntimeData(flatData, skillDatabase);
            skillCache[skillId] = data;

            return data;
        }

        Debug.LogWarning($"æŠ€èƒ½ {skillId} æœªæ‰¾åˆ°");
        return null;
    }

    /// <summary>
    /// é¢„åŠ è½½æŠ€èƒ½
    /// </summary>
    public void PreloadSkills(int[] skillIds)
    {
        foreach (int id in skillIds)
        {
            GetSkill(id);
        }
    }

    /// <summary>
    /// æ¸…é™¤ç¼“å­˜
    /// </summary>
    public void ClearCache()
    {
        skillCache.Clear();
        System.GC.Collect();
    }
}
```

### 5.2 æŠ€èƒ½è¿è¡Œæ—¶æ•°æ®

```csharp
/// <summary>
/// æŠ€èƒ½è¿è¡Œæ—¶æ•°æ®
/// </summary>
public class SkillRuntimeData
{
    public int SkillId { get; private set; }
    public SkillType SkillType { get; private set; }
    public int Damage { get; private set; }
    public float Range { get; private set; }
    public float Cooldown { get; private set; }
    public float AnimationDuration { get; private set; }

    private SkillEffectRuntimeData[] effects;

    public SkillRuntimeData(SkillFlatData flatData, SkillDatabase database)
    {
        SkillId = flatData.skillId;
        SkillType = (SkillType)flatData.skillType;
        Damage = flatData.damage;
        Range = flatData.range / 100f;
        Cooldown = flatData.cooldown / 100f;
        AnimationDuration = flatData.animationDuration / 100f;

        // åŠ è½½æ•ˆæœæ•°æ®
        var effectsSpan = database.GetEffects(flatData);
        effects = new SkillEffectRuntimeData[flatData.effectCount];
        for (int i = 0; i < effects.Length; i++)
        {
            effects[i] = new SkillEffectRuntimeData(effectsSpan[i]);
        }
    }

    /// <summary>
    /// è·å–æ‰€æœ‰æ•ˆæœ
    /// </summary>
    public ReadOnlySpan<SkillEffectRuntimeData> GetEffects()
    {
        return effects;
    }
}

/// <summary>
/// æŠ€èƒ½æ•ˆæœè¿è¡Œæ—¶æ•°æ®
/// </summary>
public struct SkillEffectRuntimeData
{
    public EffectType Type { get; private set; }
    public float Value { get; private set; }
    public float Duration { get; private set; }
    public string TargetTag { get; private set; }

    public SkillEffectRuntimeData(SkillEffectFlatData flatData)
    {
        Type = (EffectType)flatData.effectType;
        Value = flatData.value / 100f;
        Duration = flatData.duration / 100f;
        TargetTag = GetTagString(flatData.targetTagId);
    }

    private string GetTagString(int tagId)
    {
        // ä»æ ‡ç­¾è¡¨è·å–
        return "Enemy";
    }
}
```

---

## å…­ã€æ€§èƒ½å¯¹æ¯”

### 6.1 åŠ è½½æ€§èƒ½æµ‹è¯•

```csharp
using UnityEngine;
using UnityEditor;
using System.Diagnostics;

public class SkillPerformanceTest
{
    [MenuItem("Tools/Test Skill Loading Performance")]
    public static void TestLoadingPerformance()
    {
        const int skillCount = 1000;

        // æµ‹è¯• ScriptableObject åŠ è½½
        var sw1 = Stopwatch.StartNew();
        var scriptableSkills = new SkillConfig[skillCount];
        for (int i = 0; i < skillCount; i++)
        {
            scriptableSkills[i] = ScriptableObject.CreateInstance<SkillConfig>();
            // æ¨¡æ‹ŸåŠ è½½...
        }
        sw1.Stop();

        // æµ‹è¯• FlatBuffers åŠ è½½
        var sw2 = Stopwatch.StartNew();
        // æ¨¡æ‹ŸåŠ è½½ FlatBuffer æ•°æ®...
        sw2.Stop();

        UnityEngine.Debug.Log($"ScriptableObject åŠ è½½ {skillCount} ä¸ªæŠ€èƒ½: {sw1.ElapsedMilliseconds}ms");
        UnityEngine.Debug.Log($"FlatBuffers åŠ è½½ {skillCount} ä¸ªæŠ€èƒ½: {sw2.ElapsedMilliseconds}ms");
        UnityEngine.Debug.Log($"æ€§èƒ½æå‡: {(float)sw1.ElapsedMilliseconds / sw2.ElapsedMilliseconds:F2}x");
    }
}
```

### 6.2 å†…å­˜å ç”¨å¯¹æ¯”

| æ•°æ®ç±»å‹ | 1000ä¸ªæŠ€èƒ½ | å•ä¸ªæŠ€èƒ½å¹³å‡ |
|---------|-----------|------------|
| ScriptableObject | ~50MB | ~50KB |
| FlatBuffers | ~5MB | ~5KB |
| è‡ªå®šä¹‰äºŒè¿›åˆ¶ | ~2MB | ~2KB |

---

## ä¸ƒã€æ€»ç»“

æœ¬æ–‡ä»‹ç»äº†æŠ€èƒ½ç¼–è¾‘å™¨ä¸æ‰å¹³æ•°æ®ç¼“å­˜çš„æ ¸å¿ƒè¦ç‚¹ï¼š

| ä¸»é¢˜ | è¦ç‚¹ |
|------|------|
| **æ•°æ®ç»“æ„** | æ‰å¹³æ•°æ®æ¯”å¯¹è±¡æ•°æ®æ›´ç´§å‡‘ |
| **FlatBuffers** | é«˜æ•ˆçš„äºŒè¿›åˆ¶åºåˆ—åŒ–æ ¼å¼ |
| **ç¼–è¾‘å™¨** | ScriptableObject + CustomEditor |
| **ç¼“å­˜ç®¡ç†** | å•ä¾‹ç®¡ç†å™¨ + è¿è¡Œæ—¶ç¼“å­˜ |
| **æ€§èƒ½ä¼˜åŒ–** | å‡å°‘åºåˆ—åŒ–å¼€é”€å’Œå†…å­˜å ç”¨ |
| **æ•°æ®å¯¼å‡º** | ç¼–è¾‘å™¨ â†’ FlatBuffers â†’ è¿è¡Œæ—¶ |

> ğŸ’¡ **å¼€å‘å»ºè®®**ï¼š
> - ç¼–è¾‘æœŸä½¿ç”¨ ScriptableObject ä¾¿äºè°ƒè¯•
> - è¿è¡Œæ—¶ä½¿ç”¨ FlatBuffers æå‡æ€§èƒ½
> - å®ç°å¢é‡æ›´æ–°ï¼ŒåªåŠ è½½å¿…è¦æ•°æ®
> - è€ƒè™‘å¼‚æ­¥åŠ è½½å¤§é‡æŠ€èƒ½æ•°æ®
> - ä½¿ç”¨å¯¹è±¡æ± ç®¡ç†æŠ€èƒ½å®ä¾‹

---

**è½¬è½½è¯·æ³¨æ˜æ¥æº**ï¼Œæ¬¢è¿å¯¹æ–‡ç« ä¸­çš„å¼•ç”¨æ¥æºè¿›è¡Œè€ƒè¯ï¼Œæ¬¢è¿æŒ‡å‡ºä»»ä½•æœ‰é”™è¯¯æˆ–ä¸å¤Ÿæ¸…æ™°çš„è¡¨è¾¾ã€‚å¯ä»¥åœ¨ä¸‹é¢è¯„è®ºåŒºè¯„è®ºï¼Œä¹Ÿå¯ä»¥é‚®ä»¶è‡³ 1487842110@qq.com
