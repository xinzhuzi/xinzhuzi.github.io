---
title: "Unity CPU æ€§èƒ½ä¼˜åŒ–å®Œå…¨æ‰‹å†Œï¼šä»è„šæœ¬åˆ°å¤šçº¿ç¨‹çš„æ€§èƒ½æå‡ä¹‹è·¯"
date: 2020/05/08
categories: [æŠ€æœ¯æ–‡ç« , Unityå¼€å‘]
tags: [Unity, CPUä¼˜åŒ–, æ€§èƒ½, å¤šçº¿ç¨‹, Job System, Burst, åç¨‹, Profiler]
image: /images/unity-cpu-optimization-banner.jpg
---

# âš¡ Unity CPU æ€§èƒ½ä¼˜åŒ–å®Œå…¨æ‰‹å†Œï¼šä»è„šæœ¬åˆ°å¤šçº¿ç¨‹çš„æ€§èƒ½æå‡ä¹‹è·¯

> ğŸ’¡ **CPU ä¼˜åŒ–çš„ä»·å€¼**ï¼š
> - æ¸¸æˆé€»è¾‘å¤æ‚ï¼ŒCPU æˆäº†æ€§èƒ½ç“¶é¢ˆï¼Ÿ
> - æƒ³ç”¨ Job System å’Œ Burstï¼Œå´ä¸çŸ¥é“ä»ä½•å…¥æ‰‹ï¼Ÿ
> - ä¸»çº¿ç¨‹å‹åŠ›å¤ªå¤§ï¼Œå¦‚ä½•åˆ©ç”¨å¤šæ ¸ CPUï¼Ÿ
> - åç¨‹ã€å¤šçº¿ç¨‹ã€Job System è¯¥æ€ä¹ˆé€‰ï¼Ÿ
>
> **è¿™ç¯‡æ–‡ç« ï¼** å°†ç³»ç»Ÿè®²è§£ Unity CPU ä¼˜åŒ–æŠ€æœ¯ï¼Œä»åŸºç¡€è„šæœ¬ä¼˜åŒ–åˆ° Job Systemï¼Œè®©æ€§èƒ½æå‡ 10 å€ï¼

---

## ä¸€ã€CPU æ€§èƒ½åˆ†æ

### 1.1 Unity Profiler ä½¿ç”¨

**æ‰“å¼€ Profiler**ï¼š

```
Window â†’ Analysis â†’ Profiler
```

**å…³é”®æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | è¯´æ˜ | ç†æƒ³å€¼ |
|-----|------|-------|
| **CPU Usage** | ä¸»çº¿ç¨‹å ç”¨ | < 16.6ms (60fps) |
| **Script Lateupdate** | è„šæœ¬æ‰§è¡Œæ—¶é—´ | è¶Šä½è¶Šå¥½ |
| **Physics.Simulate** | ç‰©ç†æ¨¡æ‹Ÿæ—¶é—´ | < 3ms |
| **GarbageCollector** | GC é€ æˆçš„å¡é¡¿ | æœ€å°åŒ– |
| **Rendering** | GPU ç­‰å¾…æ—¶é—´ | å¹³è¡¡ CPU/GPU |

### 1.2 CPU ç“¶é¢ˆè¯†åˆ«

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CPU ç“¶é¢ˆç±»å‹è¯†åˆ«                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  ç“¶é¢ˆç±»å‹:                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  CPU Bound        â”‚  ä¸»çº¿ç¨‹è„šæœ¬è€—æ—¶è¿‡é•¿                             â”‚   â”‚
â”‚  â”‚                   â”‚  â†’ ä¼˜åŒ–ç®—æ³•ï¼Œå‡å°‘è®¡ç®—                           â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Rendering Bound  â”‚  æ¸²æŸ“ç­‰å¾…æ—¶é—´é•¿                                 â”‚   â”‚
â”‚  â”‚                   â”‚  â†’ é™ä½Draw Callï¼Œä¼˜åŒ–å‡ ä½•ä½“                     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  GC Alloc         â”‚  é¢‘ç¹å†…å­˜åˆ†é…                                   â”‚   â”‚
â”‚  â”‚                   â”‚  â†’ å‡å°‘å †åˆ†é…ï¼Œä½¿ç”¨å¯¹è±¡æ±                        â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  Physics Heavy    â”‚  ç‰©ç†æ¨¡æ‹Ÿè€—æ—¶                                   â”‚   â”‚
â”‚  â”‚                   â”‚  â†’ å‡å°‘ç¢°æ’ä½“ï¼Œç®€åŒ–ç‰©ç†                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€è„šæœ¬ä¼˜åŒ–åŸºç¡€

### 2.1 ç¼“å­˜ç»„ä»¶å¼•ç”¨

**âŒ é”™è¯¯åšæ³•**ï¼šæ¯å¸§æŸ¥æ‰¾ç»„ä»¶

```csharp
void Update()
{
    var rb = GetComponent<Rigidbody>();  // æ¯å¸§æŸ¥æ‰¾ï¼Œéå¸¸è€—æ—¶
    rb.velocity = Vector3.forward * speed;
}
```

**âœ… æ­£ç¡®åšæ³•**ï¼šç¼“å­˜ç»„ä»¶å¼•ç”¨

```csharp
private Rigidbody rb;

void Awake()
{
    rb = GetComponent<Rigidbody>();  // åªæŸ¥æ‰¾ä¸€æ¬¡
}

void Update()
{
    rb.velocity = Vector3.forward * speed;
}
```

### 2.2 é¿å…å­—ç¬¦ä¸²æ‹¼æ¥

**âŒ é”™è¯¯åšæ³•**ï¼š

```csharp
void Update()
{
    string message = "Score: " + score + ", Time: " + Time.time;  // äº§ç”Ÿ GC
    Debug.Log(message);
}
```

**âœ… æ­£ç¡®åšæ³•**ï¼š

```csharp
// æ–¹å¼ä¸€ï¼šä½¿ç”¨ StringBuilder
private System.Text.StringBuilder sb = new System.Text.StringBuilder(256);

void Update()
{
    sb.Clear();
    sb.Append("Score: ").Append(score).Append(", Time: ").Append(Time.time);
    Debug.Log(sb.ToString());
}

// æ–¹å¼äºŒï¼šå‡å°‘æ—¥å¿—é¢‘ç‡
private float logInterval = 1f;
private float logTimer;

void Update()
{
    logTimer += Time.deltaTime;
    if (logTimer >= logInterval)
    {
        Debug.Log($"Score: {score}, Time: {Time.time}");
        logTimer = 0;
    }
}
```

### 2.3 é™æ€å±æ€§ç¼“å­˜

**âŒ é”™è¯¯åšæ³•**ï¼š

```csharp
void Update()
{
    for (int i = 0; i < 1000; i++)
    {
        // Time.deltaTime æ¯æ¬¡è®¿é—®éƒ½æœ‰å¼€é”€
        transform.position += Vector3.forward * Time.deltaTime * speed;
    }
}
```

**âœ… æ­£ç¡®åšæ³•**ï¼š

```csharp
void Update()
{
    float dt = Time.deltaTime;  // ç¼“å­˜
    for (int i = 0; i < 1000; i++)
    {
        transform.position += Vector3.forward * dt * speed;
    }
}
```

### 2.4 å‡å°‘ç©ºå¼•ç”¨æ£€æŸ¥

**âŒ é”™è¯¯åšæ³•**ï¼šé¢‘ç¹ä½¿ç”¨ Find

```csharp
void Update()
{
    GameObject enemy = GameObject.Find("Enemy");  // éå†æ•´ä¸ªåœºæ™¯
    if (enemy != null)
    {
        // å¤„ç†æ•Œäºº
    }
}
```

**âœ… æ­£ç¡®åšæ³•**ï¼šä½¿ç”¨å¼•ç”¨æˆ–å¯¹è±¡æ± 

```csharp
private GameObject enemy;

void Start()
{
    enemy = GameObject.Find("Enemy");  // åªæŸ¥æ‰¾ä¸€æ¬¡
}

void Update()
{
    if (enemy != null)
    {
        // å¤„ç†æ•Œäºº
    }
}
```

---

## ä¸‰ã€Update ä¼˜åŒ–ç­–ç•¥

### 3.1 é™ä½è°ƒç”¨é¢‘ç‡

```csharp
using UnityEngine;

/// <summary>
/// åˆ†å¸§å¤„ç†ç¤ºä¾‹
/// </summary>
public class BatchProcessing : MonoBehaviour
{
    private const int TotalItems = 1000;
    private int currentIndex = 0;
    private int itemsPerFrame = 50;

    void Update()
    {
        ProcessBatch();
    }

    void ProcessBatch()
    {
        int endIndex = Mathf.Min(currentIndex + itemsPerFrame, TotalItems);

        for (int i = currentIndex; i < endIndex; i++)
        {
            ProcessItem(i);
        }

        currentIndex = endIndex >= TotalItems ? 0 : endIndex;
    }

    void ProcessItem(int index)
    {
        // å¤„ç†å•ä¸ªé¡¹ç›®
    }
}
```

### 3.2 æŒ‰è·ç¦»å‰”é™¤

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// è·ç¦»å‰”é™¤ä¼˜åŒ–
/// </summary>
public class DistanceCulling : MonoBehaviour
{
    public List<Enemy> enemies = new List<Enemy>();
    public Transform player;
    public float maxDistance = 50f;

    void Update()
    {
        float sqrDistThreshold = maxDistance * maxDistance;  // å¹³æ–¹è·ç¦»é¿å…å¼€æ–¹

        foreach (var enemy in enemies)
        {
            float sqrDist = (enemy.transform.position - player.position).sqrMagnitude;

            if (sqrDist < sqrDistThreshold)
            {
                enemy.UpdateAI();  // åªå¤„ç†èŒƒå›´å†…çš„æ•Œäºº
            }
        }
    }
}

class Enemy
{
    public Transform transform;
    public void UpdateAI() { }
}
```

### 3.3 ä½¿ç”¨åç¨‹æ›¿ä»£ Update

```csharp
using UnityEngine;
using System.Collections;

/// <summary>
/// åç¨‹æ›¿ä»£ Update
/// </summary>
public class CoroutineVsUpdate : MonoBehaviour
{
    // âŒ ä½¿ç”¨ Update
    // void Update()
    // {
    //     CheckInputs();     // æ¯å¸§è°ƒç”¨
    //     ProcessAI();       // æ¯å¸§è°ƒç”¨
    //     UpdateUI();        // æ¯å¸§è°ƒç”¨
    // }

    // âœ… ä½¿ç”¨åç¨‹
    void Start()
    {
        StartCoroutine(InputCoroutine());      // 60fps
        StartCoroutine(AICoroutine());          // 10fps
        StartCoroutine(UICoroutine());          // 5fps
    }

    IEnumerator InputCoroutine()
    {
        while (true)
        {
            CheckInputs();
            yield return null;  // æ¯å¸§æ‰§è¡Œ
        }
    }

    IEnumerator AICoroutine()
    {
        while (true)
        {
            ProcessAI();
            yield return new WaitForSeconds(0.1f);  // æ¯0.1ç§’æ‰§è¡Œ
        }
    }

    IEnumerator UICoroutine()
    {
        while (true)
        {
            UpdateUI();
            yield return new WaitForSeconds(0.2f);  // æ¯0.2ç§’æ‰§è¡Œ
        }
    }

    void CheckInputs() { }
    void ProcessAI() { }
    void UpdateUI() { }
}
```

---

## å››ã€å¤šçº¿ç¨‹ä¼˜åŒ–

### 4.1 Thread ä¸ DispatchQueue

```csharp
using UnityEngine;
using System.Threading;
using System.Collections.Generic;

/// <summary>
/// ç®€å•å¤šçº¿ç¨‹ç¤ºä¾‹
/// </summary>
public class ThreadingExample : MonoBehaviour
{
    private Thread workerThread;
    private Queue<System.Action> taskQueue = new Queue<System.Action>();
    private bool isRunning = true;
    private readonly object queueLock = new object();

    void Start()
    {
        workerThread = new Thread(WorkerLoop);
        workerThread.IsBackground = true;
        workerThread.Start();
    }

    void Update()
    {
        // ä¸»çº¿ç¨‹æ‰§è¡Œä¸€äº›å·¥ä½œ
    }

    void OnDestroy()
    {
        isRunning = false;
        if (workerThread != null && workerThread.IsAlive)
        {
            workerThread.Join();
        }
    }

    /// <summary>
    /// æ·»åŠ ä»»åŠ¡åˆ°å·¥ä½œçº¿ç¨‹
    /// </summary>
    public void EnqueueTask(System.Action task)
    {
        lock (queueLock)
        {
            taskQueue.Enqueue(task);
        }
    }

    /// <summary>
    /// å·¥ä½œçº¿ç¨‹å¾ªç¯
    /// </summary>
    private void WorkerLoop()
    {
        while (isRunning)
        {
            System.Action task = null;

            lock (queueLock)
            {
                if (taskQueue.Count > 0)
                    task = taskQueue.Dequeue();
            }

            task?.Invoke();

            Thread.Sleep(1);  // é¿å…ç©ºè½¬
        }
    }
}
```

### 4.2 UnityMainThreadDispatcher

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Threading;
using System;

/// <summary>
/// ä¸»çº¿ç¨‹è°ƒåº¦å™¨ - ä»å·¥ä½œçº¿ç¨‹å®‰å…¨åœ°è°ƒç”¨ Unity API
/// </summary>
public class UnityMainThreadDispatcher : MonoBehaviour
{
    private static UnityMainThreadDispatcher instance;
    private readonly Queue<System.Action> executionQueue = new Queue<System.Action>();

    public static UnityMainThreadDispatcher Instance
    {
        get
        {
            if (instance == null)
            {
                GameObject go = new GameObject("UnityMainThreadDispatcher");
                instance = go.AddComponent<UnityMainThreadDispatcher>();
                DontDestroyOnLoad(go);
            }
            return instance;
        }
    }

    void Update()
    {
        lock (executionQueue)
        {
            while (executionQueue.Count > 0)
            {
                executionQueue.Dequeue().Invoke();
            }
        }
    }

    /// <summary>
    /// åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œå§”æ‰˜
    /// </summary>
    public void Enqueue(System.Action action)
    {
        lock (executionQueue)
        {
            executionQueue.Enqueue(action);
        }
    }

    /// <summary>
    /// ä»å·¥ä½œçº¿ç¨‹è°ƒç”¨ Unity API
    /// </summary>
    public static void RunOnMainThread(System.Action action)
    {
        Instance.Enqueue(action);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class WorkerThreadExample
{
    private Thread worker;

    void Start()
    {
        worker = new Thread(DoWork);
        worker.Start();
    }

    void DoWork()
    {
        // åœ¨å·¥ä½œçº¿ç¨‹ä¸­è®¡ç®—
        int result = HeavyCalculation();

        // åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ“ä½œ Unity å¯¹è±¡
        UnityMainThreadDispatcher.RunOnMainThread(() =>
        {
            Debug.Log($"Result: {result}");
        });
    }

    int HeavyCalculation()
    {
        // è€—æ—¶è®¡ç®—
        return 42;
    }
}
```

---

## äº”ã€Job System ä¸ Burst

### 5.1 Job System åŸºç¡€

```csharp
using UnityEngine;
using Unity.Jobs;
using Unity.Collections;

/// <summary>
/// Job System åŸºç¡€ç¤ºä¾‹
/// </summary>
public class JobSystemExample : MonoBehaviour
{
    private NativeArray<int> numbers;
    private NativeArray<int> results;

    void Start()
    {
        // åˆå§‹åŒ–æ•°æ®
        numbers = new NativeArray<int>(1000, Allocator.TempJob);
        results = new NativeArray<int>(1000, Allocator.TempJob);

        for (int i = 0; i < 1000; i++)
        {
            numbers[i] = i;
        }
    }

    void Update()
    {
        // åˆ›å»º Job
        var job = new ProcessNumbersJob
        {
            numbers = numbers,
            results = results
        };

        // è°ƒåº¦ Job
        JobHandle jobHandle = job.Schedule(numbers.Length, 64);

        // å¯ä»¥åœ¨æ­¤æœŸé—´åšå…¶ä»–å·¥ä½œ

        // ç­‰å¾… Job å®Œæˆ
        jobHandle.Complete();

        // ä½¿ç”¨ç»“æœ
        // Debug.Log($"First result: {results[0]}");
    }

    void OnDestroy()
    {
        if (numbers.IsCreated) numbers.Dispose();
        if (results.IsCreated) results.Dispose();
    }

    /// <summary>
    /// Job ç»“æ„ä½“
    /// </summary>
    [BurstCompatible(CompileSynchronously = true)]
    private struct ProcessNumbersJob : IJobParallelFor
    {
        [ReadOnly] public NativeArray<int> numbers;
        [WriteOnly] public NativeArray<int> results;

        public void Execute(int index)
        {
            results[index] = numbers[index] * 2;
        }
    }
}
```

### 5.2 å¹¶è¡Œ Job

```csharp
using UnityEngine;
using Unity.Jobs;
using Unity.Collections;
using Unity.Burst;

/// <summary>
/// Burst ç¼–è¯‘çš„å¹¶è¡Œ Job
/// </summary>
public class BurstJobExample : MonoBehaviour
{
    [BurstCompile]
    private struct HeavyCalculationJob : IJobParallelFor
    {
        [ReadOnly] public NativeArray<float> input;
        [WriteOnly] public NativeArray<float> output;
        public float multiplier;

        public void Execute(int index)
        {
            float value = input[index];

            // å¤æ‚è®¡ç®—
            for (int i = 0; i < 100; i++)
            {
                value = Mathf.Sin(value) * Mathf.Cos(value);
                value += multiplier;
            }

            output[index] = value;
        }
    }

    public void ScheduleJob(int count)
    {
        var input = new NativeArray<float>(count, Allocator.TempJob);
        var output = new NativeArray<float>(count, Allocator.TempJob);

        // åˆå§‹åŒ–è¾“å…¥
        for (int i = 0; i < count; i++)
            input[i] = i * 0.1f;

        // åˆ›å»ºå¹¶è°ƒåº¦ Job
        var job = new HeavyCalculationJob
        {
            input = input,
            output = output,
            multiplier = 2f
        };

        JobHandle jobHandle = job.Schedule(count, 64);
        jobHandle.Complete();

        // ä½¿ç”¨ç»“æœ...

        input.Dispose();
        output.Dispose();
    }
}
```

### 5.3 Job Chain

```csharp
using UnityEngine;
using Unity.Jobs;
using Unity.Collections;
using Unity.Burst;

/// <summary>
/// Job é“¾å¼ä¾èµ–
/// </summary>
public class JobChainExample : MonoBehaviour
{
    private NativeArray<int> data;

    void Start()
    {
        data = new NativeArray<int>(1000, Allocator.Persistent);

        for (int i = 0; i < 1000; i++)
            data[i] = i;
    }

    void Update()
    {
        // åˆ›å»ºå¤šä¸ª Job
        var initJob = new InitializeJob { data = data };
        var processJob = new ProcessJob { data = data };
        var finalizeJob = new FinalizeJob { data = data };

        // é“¾å¼è°ƒåº¦
        JobHandle initHandle = initJob.Schedule();
        JobHandle processHandle = processJob.Schedule(data.Length, 64, initHandle);
        JobHandle finalizeHandle = finalizeJob.Schedule(processHandle);

        // ç­‰å¾…æ‰€æœ‰ Job å®Œæˆ
        finalizeHandle.Complete();
    }

    void OnDestroy()
    {
        if (data.IsCreated) data.Dispose();
    }

    [BurstCompile]
    private struct InitializeJob : IJobParallelFor
    {
        public NativeArray<int> data;

        public void Execute(int index)
        {
            data[index] = index;
        }
    }

    [BurstCompile]
    private struct ProcessJob : IJobParallelFor
    {
        public NativeArray<int> data;

        public void Execute(int index)
        {
            data[index] = data[index] * 2;
        }
    }

    [BurstCompile]
    private struct FinalizeJob : IJob
    {
        public NativeArray<int> data;

        public void Execute()
        {
            int sum = 0;
            for (int i = 0; i < data.Length; i++)
                sum += data[i];

            data[0] = sum;  // å­˜å‚¨ç»“æœ
        }
    }
}
```

---

## å…­ã€ç‰©ç†ä¼˜åŒ–

### 6.1 å›ºå®šæ—¶é—´æ­¥é•¿è®¾ç½®

```csharp
using UnityEngine;

/// <summary>
/// ç‰©ç†æ›´æ–°é¢‘ç‡æ§åˆ¶
/// </summary>
public class PhysicsOptimization : MonoBehaviour
{
    [Header("ç‰©ç†è®¾ç½®")]
    [Tooltip("å›ºå®šæ›´æ–°é¢‘ç‡")]
    public int fixedFrequency = 50;  // 50Hz

    [Tooltip("æœ€å¤§å…è®¸æ—¶é—´æ­¥é•¿")]
    public float maximumTimeStep = 0.02f;

    void Start()
    {
        // è®¾ç½®å›ºå®šæ—¶é—´æ­¥é•¿
        Time.fixedDeltaTime = 1f / fixedFrequency;

        // è®¾ç½®æœ€å¤§æ—¶é—´æ­¥é•¿ï¼ˆé˜²æ­¢ä½å¸§ç‡æ—¶çš„ç‰©ç†çˆ†ç‚¸ï¼‰
        Physics.maxDeltaTime = maximumTimeStep;
    }
}
```

### 6.2 ç¢°æ’ä½“ä¼˜åŒ–

```csharp
using UnityEngine;

/// <summary>
/// ç¢°æ’æ£€æµ‹ä¼˜åŒ–
/// </summary>
public class CollisionOptimization : MonoBehaviour
{
    [Header("ç¢°æ’è®¾ç½®")]
    public LayerMask collisionLayers;
    public float checkInterval = 0.1f;

    private float checkTimer;
    private Collider[] results = new Collider[10];

    void Update()
    {
        // âŒ é”™è¯¯ï¼šæ¯å¸§æ£€æµ‹
        // Collider[] hits = Physics.OverlapSphere(transform.position, 5f);

        // âœ… æ­£ç¡®ï¼šå®šæ—¶æ£€æµ‹
        checkTimer += Time.deltaTime;
        if (checkTimer >= checkInterval)
        {
            CheckCollisions();
            checkTimer = 0;
        }
    }

    void CheckCollisions()
    {
        int hitCount = Physics.OverlapSphereNonAlloc(
            transform.position,
            5f,
            results,
            collisionLayers,
            QueryTriggerInteraction.Ignore
        );

        for (int i = 0; i < hitCount; i++)
        {
            HandleCollision(results[i]);
        }
    }

    void HandleCollision(Collider collider)
    {
        // å¤„ç†ç¢°æ’
    }
}
```

### 6.3 Rigidbody é…ç½®

| ä¼˜åŒ–é¡¹ | è®¾ç½® | æ•ˆæœ |
|-------|------|------|
| **Interpolate** | ç¦ç”¨ï¼ˆå¦‚æœä¸éœ€è¦å¹³æ»‘æ’å€¼ï¼‰ | èŠ‚çœ CPU |
| **Collision Detection** | Discreteï¼ˆç¦»æ•£ï¼‰ | å‡å°‘è¿ç»­æ£€æµ‹å¼€é”€ |
| **Constraints** | å‡å°‘çº¦æŸæ•°é‡ | ç®€åŒ–ç‰©ç†è®¡ç®— |
| **Sleep Mode** | å¯ç”¨ä¼‘çœ  | å‡å°‘é™æ€ç‰©ä½“è®¡ç®— |

```csharp
using UnityEngine;

/// <summary>
/// Rigidbody ä¼˜åŒ–é…ç½®
/// </summary>
public class RigidbodyOptimization : MonoBehaviour
{
    void Start()
    {
        Rigidbody rb = GetComponent<Rigidbody>();

        // ä¼˜åŒ–é…ç½®
        rb.interpolation = RigidbodyInterpolation.None;  // ç¦ç”¨æ’å€¼
        rb.collisionDetectionMode = CollisionDetectionMode.Discrete;  // ç¦»æ•£æ£€æµ‹
        rb.sleepMode = RigidbodySleepMode.StartAwake;  // å…è®¸ä¼‘çœ 
    }
}
```

---

## ä¸ƒã€å†…å­˜ä¼˜åŒ–

### 7.1 å‡å°‘è£…ç®±æ‹†ç®±

**âŒ äº§ç”Ÿè£…ç®±çš„ä»£ç **ï¼š

```csharp
// 1. å€¼ç±»å‹ä½œä¸º object ä¼ é€’
void ProcessValue(object value) { }
ProcessValue(42);  // è£…ç®±

// 2. æ•°ç»„åå˜
ArrayList list = new ArrayList();
list.Add(42);  // è£…ç®±
int value = (int)list[0];  // æ‹†ç®±

// 3. å­—ç¬¦ä¸²æ‹¼æ¥
string text = "Value: " + 42;  // è£…ç®±
```

**âœ… é¿å…è£…ç®±çš„ä»£ç **ï¼š

```csharp
// 1. ä½¿ç”¨æ³›å‹
void ProcessValue<T>(T value) where T : struct { }
ProcessValue(42);

// 2. ä½¿ç”¨ List<T>
List<int> list = new List<int>();
list.Add(42);
int value = list[0];

// 3. ä½¿ç”¨ StringBuilder æˆ–å­—ç¬¦ä¸²æ’å€¼
string text = $"Value: {42}";
```

### 7.2 å¯¹è±¡æ± å®ç°

```csharp
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// é€šç”¨å¯¹è±¡æ± 
/// </summary>
public class ObjectPool<T> where T : class, new()
{
    private readonly Stack<T> pool = new Stack<T>();
    private readonly System.Action<T> resetAction;
    private readonly int maxSize;

    public ObjectPool(int initialSize = 10, int maxSize = 100, System.Action<T> resetAction = null)
    {
        this.maxSize = maxSize;
        this.resetAction = resetAction;

        for (int i = 0; i < initialSize; i++)
        {
            pool.Push(new T());
        }
    }

    public T Get()
    {
        if (pool.Count > 0)
        {
            return pool.Pop();
        }

        return new T();
    }

    public void Return(T obj)
    {
        if (pool.Count < maxSize)
        {
            resetAction?.Invoke(obj);
            pool.Push(obj);
        }
    }

    public int PooledCount => pool.Count;
}

/// <summary>
/// GameObject å¯¹è±¡æ± 
/// </summary>
public class GameObjectPool
{
    private readonly Stack<GameObject> pool = new Stack<GameObject>();
    private readonly GameObject prefab;
    private readonly int maxSize;
    private readonly Transform container;

    public GameObjectPool(GameObject prefab, int initialSize = 5, int maxSize = 50)
    {
        this.prefab = prefab;
        this.maxSize = maxSize;
        this.container = new GameObject($"Pool_{prefab.name}").transform;

        // é¢„åˆ›å»º
        for (int i = 0; i < initialSize; i++)
        {
            GameObject obj = Object.Instantiate(prefab, container);
            obj.SetActive(false);
            pool.Push(obj);
        }
    }

    public GameObject Get()
    {
        GameObject obj;

        if (pool.Count > 0)
        {
            obj = pool.Pop();
        }
        else
        {
            obj = Object.Instantiate(prefab, container);
        }

        obj.SetActive(true);
        return obj;
    }

    public void Return(GameObject obj)
    {
        if (pool.Count < maxSize)
        {
            obj.SetActive(false);
            pool.Push(obj);
        }
        else
        {
            Object.Destroy(obj);
        }
    }

    public int PooledCount => pool.Count;
}
```

---

## å…«ã€æ€§èƒ½æ£€æŸ¥æ¸…å•

### 8.1 ä»£ç å®¡æŸ¥æ¸…å•

| ç±»åˆ« | æ£€æŸ¥é¡¹ | çŠ¶æ€ |
|-----|-------|------|
| **ç»„ä»¶å¼•ç”¨** | ç¼“å­˜ GetComponent ç»“æœ | â¬œ |
| **Update** | é¿å…æ¯å¸§æŸ¥æ‰¾å¯¹è±¡ | â¬œ |
| **å­—ç¬¦ä¸²** | é¿å…é¢‘ç¹å­—ç¬¦ä¸²æ‹¼æ¥ | â¬œ |
| **åç¨‹** | ä½¿ç”¨åç¨‹æ›¿ä»£é«˜é¢‘ Update | â¬œ |
| **æ•°å­¦** | é¿å…åœ¨å¾ªç¯ä¸­é‡å¤è®¡ç®— | â¬œ |
| **è£…ç®±** | é¿å…è£…ç®±æ‹†ç®± | â¬œ |
| **ç©ºæ£€æŸ¥** | é¿å…æ¯å¸§çš„ç©ºå¼•ç”¨æ£€æŸ¥ | â¬œ |
| **ç‰©ç†** | é™ä½ç‰©ç†æ›´æ–°é¢‘ç‡ | â¬œ |
| **GC** | å‡å°‘ Per-frame GC Alloc | â¬œ |
| **å¤šçº¿ç¨‹** | ä½¿ç”¨ Job System å¤„ç†å¹¶è¡Œä»»åŠ¡ | â¬œ |

### 8.2 Profiler æ£€æŸ¥ç‚¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Profiler æ£€æŸ¥è¦ç‚¹                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. Rendering:                                                         â”‚
â”‚     â””â”€â”€ æ£€æŸ¥ Draw Calls å’Œ Batches                                    â”‚
â”‚                                                                         â”‚
â”‚  2. Scripts:                                                           â”‚
â”‚     â””â”€â”€ æŸ¥æ‰¾è€—æ—¶æœ€é•¿çš„è„šæœ¬å‡½æ•°                                         â”‚
â”‚                                                                         â”‚
â”‚  3. GC Alloc:                                                         â”‚
â”‚     â””â”€â”€ æ‰¾å‡ºäº§ç”Ÿå†…å­˜åˆ†é…çš„ä»£ç è¡Œ                                        â”‚
â”‚                                                                         â”‚
â”‚  4. Physics:                                                           â”‚
â”‚     â””â”€â”€ æ£€æŸ¥ Physics.Simulate å æ¯”                                       â”‚
â”‚                                                                         â”‚
â”‚  5. GUI:                                                               â”‚
â”‚     â””â”€â”€ æ£€æŸ¥ UI é‡ç»˜å’Œå¸ƒå±€é‡å»º                                          â”‚
â”‚                                                                         â”‚
â”‚  6. Animation:                                                         â”‚
â”‚     â””â”€â”€ æ£€æŸ¥ Animation.Update å æ¯”                                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¹ã€æ€»ç»“

| ä¸»é¢˜ | è¦ç‚¹ |
|-----|------|
| **åˆ†æå·¥å…·** | Unity Profiler + Deep Profile |
| **è„šæœ¬ä¼˜åŒ–** | ç¼“å­˜ç»„ä»¶ï¼Œé¿å…æ¯å¸§æŸ¥æ‰¾ |
| **Update ä¼˜åŒ–** | ä½¿ç”¨åç¨‹ï¼Œé™ä½è°ƒç”¨é¢‘ç‡ |
| **å¤šçº¿ç¨‹** | Thread + Dispatcher æˆ– Job System |
| **é«˜æ€§èƒ½** | Job System + Burst Compiler |
| **ç‰©ç†ä¼˜åŒ–** | é™ä½é¢‘ç‡ï¼Œç®€åŒ–ç¢°æ’ä½“ |
| **å†…å­˜ä¼˜åŒ–** | å¯¹è±¡æ± ï¼Œé¿å…è£…ç®± |
| **æ‰¹é‡å¤„ç†** | åˆ†å¸§å¤„ç†å¤§é‡å¯¹è±¡ |

> ğŸ’¡ **æ ¸å¿ƒåŸåˆ™**ï¼š
> - å…ˆæµ‹é‡å†ä¼˜åŒ–
> - ä¼˜åŒ–æœ€è€—æ—¶çš„éƒ¨åˆ†
> - é¿å…è¿‡æ—©ä¼˜åŒ–
> - è€ƒè™‘ä½¿ç”¨ Job System å¤„ç†å¹¶è¡Œè®¡ç®—
> - ä½¿ç”¨ Burst Compiler è·å¾—åŸç”Ÿæ€§èƒ½
> - å¯¹è±¡æ± æ˜¯å‡å°‘ GC çš„åˆ©å™¨

---

**è½¬è½½è¯·æ³¨æ˜æ¥æº**ï¼Œæ¬¢è¿å¯¹æ–‡ç« ä¸­çš„å¼•ç”¨æ¥æºè¿›è¡Œè€ƒè¯ï¼Œæ¬¢è¿æŒ‡å‡ºä»»ä½•æœ‰é”™è¯¯æˆ–ä¸å¤Ÿæ¸…æ™°çš„è¡¨è¾¾ã€‚å¯ä»¥åœ¨ä¸‹é¢è¯„è®ºåŒºè¯„è®ºï¼Œä¹Ÿå¯ä»¥é‚®ä»¶è‡³ 1487842110@qq.com
