---
title: "Unity GC å†…å­˜ä¼˜åŒ–å®Œå…¨æŒ‡å—ï¼šå½»åº•å‘Šåˆ«å¡é¡¿çš„ç»ˆææ‰‹å†Œ"
date: 2020/05/08
categories: [æŠ€æœ¯æ–‡ç« , Unityå¼€å‘]
tags: [Unity, GC, å†…å­˜ä¼˜åŒ–, æ€§èƒ½, Boehm, å¯¹è±¡æ± , Unsafe, IL2CPP]
image: /images/unity-gc-optimization-banner.jpg
---

# â™»ï¸ Unity GC å†…å­˜ä¼˜åŒ–å®Œå…¨æŒ‡å—ï¼šå½»åº•å‘Šåˆ«å¡é¡¿çš„ç»ˆææ‰‹å†Œ

> ğŸ’¡ **GC ä¼˜åŒ–çš„ä»·å€¼**ï¼š
> - æ¸¸æˆæ¯éš”å‡ ç§’å°±å¡ä¸€ä¸‹ï¼ŒGC å¯¼è‡´çš„ï¼Ÿ
> - æƒ³å‡å°‘ GC è§¦å‘æ¬¡æ•°ï¼Œå´ä¸çŸ¥é“æ€ä¹ˆåšï¼Ÿ
> - å¯¹è±¡æ± ã€ç¼“å­˜ã€å€¼ç±»å‹ï¼Œå“ªä¸ªæ›´é€‚åˆä½ çš„åœºæ™¯ï¼Ÿ
> - æƒ³æ·±å…¥ç†è§£ GC åŸç†ï¼Œä»æ ¹æœ¬ä¸Šè§£å†³é—®é¢˜ï¼Ÿ
>
> **è¿™ç¯‡æ–‡ç« ï¼** å°†æ·±å…¥è§£æ Unity GC æœºåˆ¶ï¼Œä»åŸç†åˆ°å®è·µï¼Œæä¾› 24 ä¸ªå®æˆ˜ä¼˜åŒ–æŠ€å·§ï¼Œè®©å†…å­˜åˆ†é…æ›´é«˜æ•ˆï¼

---

## ä¸€ã€å†…å­˜ç®¡ç†æ–¹å¼æ¦‚è§ˆ

### 1.1 ä¸‰ç§å†…å­˜ç®¡ç†æ¨¡å¼

| æ¨¡å¼ | ä»£è¡¨æŠ€æœ¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|-----|---------|------|------|
| **æ‰‹åŠ¨ç®¡ç†** | C/C++ malloc/free | é€Ÿåº¦å¿«ï¼Œæ— é¢å¤–å¼€é”€ | å®¹æ˜“å†…å­˜æ³„éœ²ã€é‡æŒ‡é’ˆ |
| **åŠè‡ªåŠ¨ç®¡ç†** | å¼•ç”¨è®¡æ•° (Reference Count) | è‡ªåŠ¨å›æ”¶ï¼Œé€Ÿåº¦å¿« | å­˜åœ¨å¾ªç¯å¼•ç”¨é—®é¢˜ |
| **å…¨è‡ªåŠ¨ç®¡ç†** | è¿½è¸ªå¼ GC (Tracing GC) | æ— éœ€å…³å¿ƒé‡Šæ”¾ | æœ‰æ€§èƒ½å¼€é”€ |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Unity GC å·¥ä½œåŸç†                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Mark é˜¶æ®µ:                        Sweep é˜¶æ®µ:                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚ GC Root â”‚â”€â”€â”€æ ‡è®°å¯è¾¾å¯¹è±¡â”€â”€â”€â”€â”€â”€> â”‚ å›æ”¶æœªæ ‡è®° â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚   å¯¹è±¡    â”‚                          â”‚
â”‚       â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚       â–¼                                                                 â”‚
â”‚  æ‰€æœ‰å¯è¾¾å¯¹è±¡è¢«æ ‡è®°                                                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€Unity GC ç‰¹æ€§

### 2.1 Boehm-Demers-Weiser GC

Unity ä½¿ç”¨çš„ GC å™¨å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

| ç‰¹æ€§ | è¯´æ˜ | å½±å“ |
|-----|------|------|
| **Stop The World** | GC æ—¶æ‰€æœ‰çº¿ç¨‹å¿…é¡»åœæ­¢ | ä¼šé€ æˆå¡é¡¿ |
| **ä¸åˆ†ä»£** | æ•´ä¸ªæ‰˜ç®¡å †ç»Ÿä¸€æ‰«æ | GC é€Ÿåº¦è¾ƒæ…¢ |
| **ä¸å‹ç¼©** | ä¸è¿›è¡Œç¢ç‰‡æ•´ç† | äº§ç”Ÿå†…å­˜ç¢ç‰‡ |

> âš ï¸ **é‡è¦**ï¼šå³ä½¿ Unity 2019+ çš„å¢é‡å¼ GCï¼Œå›æ”¶æ—¶ä»éœ€åœæ­¢æ‰€æœ‰çº¿ç¨‹ã€‚

### 2.2 å†…å­˜ç¢ç‰‡é—®é¢˜

```
å †å†…å­˜å¸ƒå±€ (ä¸å‹ç¼© GC):

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”€â”€â”€â”
â”‚ A â”‚  â–  â”‚Bâ”‚  â–    â”‚Câ”‚ â– â”‚   D    â”‚ â– â”‚  E â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”€â”€â”€â”˜
   â–  = ç©ºç™½é—´éš™ (æ— æ³•åˆå¹¶)
```

å½“ç”³è¯·æ–°å¯¹è±¡æ—¶ï¼Œå¦‚æœæ²¡æœ‰å•ä¸ªé—´éš™å¤§äºå¯¹è±¡å¤§å°ï¼Œå †å†…å­˜å°±ä¼šå¢åŠ ã€‚

---

## ä¸‰ã€å½±å“ GC æ€§èƒ½çš„æ ¸å¿ƒå› ç´ 

### 3.1 å¯è¾¾å¯¹è±¡æ•°é‡

å‡å°‘å¯¹è±¡æ•°é‡çš„æ–¹æ³•ï¼š

```csharp
// âŒ é”™è¯¯ï¼šæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ç‹¬ç«‹å¯¹è±¡
class Item {
    public int a;
    public short b;
}
Item[] items; // GC æ—¶éœ€è¦éå†æ¯ä¸ªå…ƒç´ 

// âœ… æ­£ç¡®ï¼šæ•°ç»„åªæœ‰ä¸€ä¸ªå¯¹è±¡
class Item {
    public int[] a;
    public short[] b;
}
Item item; // GC åªéœ€éå†ä¸€ä¸ªå¯¹è±¡
```

### 3.2 æ‰˜ç®¡å †å¤§å°

ä¼˜åŒ–ç­–ç•¥ï¼š
1. **å‡å°‘ä¸´æ—¶åˆ†é…** - ä½¿ç”¨åˆå§‹åŒ–åˆ†é…å’Œé¢„åˆ†é…
2. **å‡å°‘å†…å­˜æ³„éœ²** - é˜²æ­¢å­¤å²›æ•ˆåº”å’Œå¾ªç¯å¼•ç”¨

---

## å››ã€ç±»ä¸ç»“æ„ä½“

### 4.1 å†…å­˜ç»“æ„å¯¹æ¯”

```
ç±»å¯¹è±¡å†…å­˜å¸ƒå±€ (å †ä¸­):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ vtable  â”‚ Monitor  â”‚   å­—æ®µæ•°æ®      â”‚
â”‚ (IntPtr) â”‚ (IntPtr) â”‚  (å¯¹é½æ’åˆ—)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   4/8å­—èŠ‚    4/8å­—èŠ‚      æ ¹æ®å­—æ®µ

ç»“æ„ä½“å†…å­˜å¸ƒå±€ (æ ˆä¸­):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     å­—æ®µæ•°æ®          â”‚
â”‚    (ç´§å‡‘å¯¹é½)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

| ç±»å‹ | å­˜å‚¨ä½ç½® | å¯¹é½å»ºè®® |
|-----|---------|---------|
| **ç±»** | å † (å®ä¾‹) | å°½é‡ç´§å‡‘æ’åˆ— |
| **ç»“æ„ä½“** | æ ˆ / å † (è£…ç®±) | éµå®ˆå¯¹é½è§„åˆ™ |

### 4.2 è£…ç®±æ‹†ç®±åœºæ™¯

| åœºæ™¯ | æ˜¯å¦è£…ç®± | è§£å†³æ–¹æ¡ˆ |
|-----|---------|---------|
| ç»“æ„ä½“ â†’ æ¥å£ | âœ… æ˜¯ | é¿å…æ¥å£è½¬æ¢ |
| å€¼ç±»å‹.GetType() | âœ… æ˜¯ | ç¼“å­˜ç±»å‹ |
| ç»“æ„ä½“.ToString() | Mono/IL2CPP ä¸åŒ | é‡å†™æ–¹æ³• |
| å®¹å™¨ç±»æ“ä½œ | éƒ¨åˆ†æ˜¯ | ä½¿ç”¨æ³›å‹ |

---

## äº”ã€å‚æ•°ä¼ é€’ä¼˜åŒ–

### 5.1 å€¼ä¼ é€’ vs å¼•ç”¨ä¼ é€’

```csharp
// âŒ ç»“æ„ä½“æŒ‰å€¼ä¼ é€’ - å¤åˆ¶æ•´ä¸ªç»“æ„ä½“
void Calc1(UnityEngine.Ray ray2) { }

// âœ… ä½¿ç”¨ ref æŒ‰å¼•ç”¨ä¼ é€’ - åªå¤åˆ¶å¼•ç”¨
void Calc1(ref UnityEngine.Ray ray2) { }
```

### 5.2 refã€inã€out å¯¹æ¯”

| å…³é”®å­— | å«ä¹‰ | ä½¿ç”¨åœºæ™¯ |
|-------|------|---------|
| **ref** | å¯è¯»å†™å¼•ç”¨ | å¤§äº IntPtr.Size çš„ç»“æ„ä½“ |
| **in** | åªè¯»å¼•ç”¨ | ä¸åº”è¢«ä¿®æ”¹çš„å‚æ•° |
| **out** | åªå†™å¼•ç”¨ (ç±»ä¼¼è¿”å›å€¼) | å¤šè¿”å›å€¼ |

### 5.3 ref return æœ€ä½³å®è·µ

```csharp
public class Test
{
    private UnityEngine.Ray _ray;

    // âœ… æ¨èï¼šè¿”å›åªè¯»å¼•ç”¨
    public ref readonly UnityEngine.Ray ray => ref _ray;

    void Calc()
    {
        // å¤åˆ¶å¼•ç”¨ï¼Œä¸æ˜¯ç»“æ„ä½“
        ref UnityEngine.Ray ray1 = ref ray;
        Calc1(ref ray1);
    }

    void Calc1(ref UnityEngine.Ray ray2) { }
}
```

> âš ï¸ **è­¦å‘Š**ï¼šref return ä¸€å®šä¸è¦è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨ï¼

---

## å…­ã€æ³›å‹ä¸è£…ç®±ä¼˜åŒ–

### 6.1 object å‚æ•° vs æ³›å‹

```csharp
// âŒ ä½¿ç”¨ object å‚æ•° - å€¼ç±»å‹ä¼šè£…ç®±
void Func(object o) { }

// âœ… ä½¿ç”¨æ³›å‹ - é¿å…è£…ç®±
void Func<T>(T o) { }
```

### 6.2 IL2CPP æ³›å‹å…±äº«æœºåˆ¶

| ç±»å‹ | æ³›å‹å…±äº« | è¯´æ˜ |
|-----|---------|------|
| **å¼•ç”¨ç±»å‹** | âœ… å…±äº« | å…±äº« RuntimeObject |
| **æ•´æ•°/æšä¸¾** | âœ… å…±äº« | å…±äº« int32_t |
| **å…¶ä»–å€¼ç±»å‹** | âŒ ä¸å…±äº« | æ¯ä¸ªç±»å‹å•ç‹¬ç”Ÿæˆ |

---

## ä¸ƒã€å¯å˜å‚æ•°ä¼˜åŒ–

### 7.1 params çš„æ€§èƒ½é—®é¢˜

```csharp
void Func(params int[] n);

Func(1, 2, 3);  // âŒ ç­‰ä»·äº new int[]{1,2,3}
Func();         // âœ… ç­‰ä»·äº Array.Empty<int>
```

### 7.2 é‡è½½ä¼˜åŒ–æ–¹æ¡ˆ

```csharp
// âœ… å¸¸ç”¨å‚æ•°æ•°é‡å•ç‹¬å®ç°
public static string Format(string format, object arg0);
public static string Format(string format, object arg0, object arg1);
public static string Format(string format, object arg0, object arg1, object arg2);
public static string Format(string format, params object[] args);
```

---

## å…«ã€æ¡ä»¶ç¼–è¯‘ä¼˜åŒ–

### 8.1 Debug.Log çš„ GC é—®é¢˜

```csharp
// âŒ å³ä½¿æ—¥å¿—å…³é—­ï¼Œå‚æ•°ä»ä¼šé€ æˆ GC Alloc
Debug.Log(123);
Debug.Log(string.Format("12{0}", 3));
```

### 8.2 Conditional ç‰¹æ€§

```csharp
// âœ… ä½¿ç”¨ Conditional ç‰¹æ€§
[Conditional("UNITY_EDITOR")]
public static void Print(object message)
{
    Debug.Log(message);
}

// çœŸæœºä¸Šä¸ä¼šç”Ÿæˆä»»ä½•ä»£ç 
Print(123);
Print(string.Format("12{0}", 3));
```

---

## ä¹ã€æ•°ç»„å†…å­˜å¸ƒå±€ä¸ç¼“å­˜

### 9.1 å¼•ç”¨ç±»å‹æ•°ç»„

```
å¼•ç”¨ç±»å‹æ•°ç»„ (ä¸è¿ç»­):
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚Ref1â”‚Ref2â”‚Ref3â”‚Ref4â”‚  â”€â”
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜   â”‚ å¼•ç”¨
  â”‚    â”‚    â”‚    â”‚     â”‚ (è¿ç»­)
  â–¼    â–¼    â–¼    â–¼     â”˜
 Obj  Obj  Obj  Obj     â”€â†’ æ•°æ® (ä¸è¿ç»­)

ç¼“å­˜å‘½ä¸­ç‡: ä½
```

### 9.2 å€¼ç±»å‹æ•°ç»„

```
å€¼ç±»å‹æ•°ç»„ (è¿ç»­):
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ D1 â”‚ D2 â”‚ D3 â”‚ D4 â”‚ D5 â”‚ D6 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
     æ•°æ® (è¿ç»­å†…å­˜)

ç¼“å­˜å‘½ä¸­ç‡: é«˜
```

---

## åã€å®¹å™¨æ•°æ®ç»“æ„

### 10.1 List/Stack/Queue æ‰©å®¹æœºåˆ¶

```csharp
// æ‰©å®¹ä¼ªä»£ç 
if(Count + 1 > array.Length)
{
    var newArray = new T[array.Length * 2];  // 2å€æ‰©å®¹
    Array.Copy(array, 0, newArray, array.Length);
    array = newArray;  // æ—§æ•°ç»„æˆä¸ºåƒåœ¾
}
```

| å®¹å™¨ | æ‰©å®¹ç­–ç•¥ | å»ºè®® |
|-----|---------|------|
| **List** | 2å€ | é¢„è®¾ Capacity |
| **Stack** | 2å€ | é¢„è®¾ Capacity |
| **Queue** | 2å€ | é¢„è®¾ Capacity |
| **Dictionary** | >2å€çš„ç´ æ•° | é¢„è®¾ Capacity |
| **HashSet** | >2å€çš„ç´ æ•° | é¢„è®¾ Capacity |

### 10.2 LinkedList å†…å­˜ç‰¹æ€§

```
LinkedList å†…å­˜å¸ƒå±€:
â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”
â”‚Nodeâ”‚â”€â”€â”€>â”‚Nodeâ”‚â”€â”€â”€>â”‚Nodeâ”‚
â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜
   â–²          â–¼          â–¼
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      ä¸è¿ç»­å†…å­˜
```

- å®Œå…¨ä¸è¿ç»­å†…å­˜
- ä½¿ç”¨èŠ‚ç‚¹æ± å¯å‡å°‘ GC
- é€‚åˆé¢‘ç¹æ’å…¥/åˆ é™¤åœºæ™¯

---

## åä¸€ã€å®¹å™¨è£…ç®±é—®é¢˜

### 11.1 å¸¸è§è£…ç®±åœºæ™¯

| åœºæ™¯ | æ˜¯å¦è£…ç®± | è§£å†³æ–¹æ¡ˆ |
|-----|---------|---------|
| foreach (Unity 5.6+) | âŒ å·²ä¿®å¤ | æ— éœ€å¤„ç† |
| æ¥å£å‚æ•° (ICollection<T>) | âœ… ä¼šè£…ç®± | é¿å…ä½¿ç”¨ |
| Dictionary ç»“æ„ä½“ Key | âœ… ä¼šè£…ç®± | å®ç° IEqualityComparer<T> |
| Dictionary æšä¸¾ Key | .NET 4.x+ å·²ä¿®å¤ | å‡çº§ runtime |

### 11.2 LINQ æ³¨æ„äº‹é¡¹

> âš ï¸ **é‡è¦**ï¼šLinq è¦é¿å…ä½¿ç”¨ï¼Œé™¤éå®Œå…¨ç†è§£å…¶æºç ï¼

---

## åäºŒã€å¯¹è±¡æ± å®ç°

### 12.1 UGUI é€šç”¨å¯¹è±¡æ± 

```csharp
class ObjectPool<T> where T : new()
{
    private readonly Stack<T> m_Stack = new Stack<T>();
    private readonly UnityAction<T> m_ActionOnGet;
    private readonly UnityAction<T> m_ActionOnRelease;

    public int countAll { get; private set; }
    public int countActive => countAll - countInactive;
    public int countInactive => m_Stack.Count;

    public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)
    {
        m_ActionOnGet = actionOnGet;
        m_ActionOnRelease = actionOnRelease;
    }

    public T Get()
    {
        T element;
        if (m_Stack.Count == 0)
        {
            element = new T();
            countAll++;
        }
        else
        {
            element = m_Stack.Pop();
        }
        m_ActionOnGet?.Invoke(element);
        return element;
    }

    public void Release(T element)
    {
        if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))
            Debug.LogError("Trying to destroy object that is already released.");
        m_ActionOnRelease?.Invoke(element);
        m_Stack.Push(element);
    }
}
```

### 12.2 NGUI BetterListPool

```csharp
public class BetterListPool<T>
{
    public const int MAX_COUNT = 16;
    PoolStack<T[]>[] pool = new PoolStack<T[]>[MAX_COUNT];

    public T[] Alloc(int n)
    {
        n = NextPowerOfTwo(n);
        int pos = GetSlot(n);

        if (pos >= 0 && pos < MAX_COUNT)
        {
            PoolStack<T[]> list = pool[pos];
            if (list.size > 0)
                return list.Pop();
        }
        return new T[n];
    }

    public void Collect(T[] buffer)
    {
        int pos = GetSlot(buffer.Length);
        if (pos >= 0 && pos < MAX_COUNT)
            pool[pos].Push(buffer);
    }
}
```

---

## åä¸‰ã€UGUI ListPool

### 13.1 BaseMeshEffect ä¼˜åŒ–

```csharp
// âœ… ä½¿ç”¨ ListPool ä¼˜åŒ– BaseMeshEffect
public override void ModifyMesh(VertexHelper vh)
{
    if (!IsActive()) return;

    var verts = ListPool<UIVertex>.Get();
    vh.GetUIVertexStream(verts);
    // ... ä¿®æ”¹é¡¶ç‚¹ ...
    vh.Clear();
    vh.AddUIVertexTriangleStream(verts);
    ListPool<UIVertex>.Release(verts);
}
```

### 13.2 Text ç‰¹æ®Šå¤„ç†

> âš ï¸ **æ³¨æ„**ï¼šUIVertex å¤§å° 76 å­—èŠ‚ï¼ŒText å­—æ•°å¤šæ—¶ä¼šæ’‘å¤§ç¼“å­˜ã€‚

```csharp
// âœ… ä½¿ç”¨ VertexHelper å†…éƒ¨æ–¹æ³•
vh.PopulateUIVertex(ref vert, index);
vh.SetUIVertex(vert, index);
vh.AddVert(vert);
```

---

## åå››ã€LinkedList èŠ‚ç‚¹æ± 

```csharp
public class PooledLinkedList<T> : LinkedList<T>
{
    static Stack<LinkedListNode<T>> s_pool = new Stack<LinkedListNode<T>>(10);

    private LinkedListNode<T> Create(T t)
    {
        LinkedListNode<T> node = s_pool.Count > 0
            ? s_pool.Pop()
            : new LinkedListNode<T>(t);

        if (s_pool.Count > 0) node.Value = t;
        return node;
    }

    public new void Remove(LinkedListNode<T> n)
    {
        int count = Count;
        base.Remove(n);
        if (count != Count) s_pool.Push(n);
    }
}
```

---

## åäº”ã€å­—ç¬¦ä¸²ä¼˜åŒ–

### 15.1 å­—ç¬¦ä¸²ä¸å¯å˜é—®é¢˜

```csharp
// âŒ æ¯æ¬¡æ‹¼æ¥ç”Ÿæˆæ–°å­—ç¬¦ä¸²
str = "a" + "b" + "c";

// âœ… ä½¿ç”¨ StringBuilder
StringBuilder sb = new StringBuilder();
sb.Append("a").Append("b").Append("c");
```

### 15.2 String Intern æ± 

| ç±»å‹ | è¯´æ˜ |
|-----|------|
| **å†…ç½®æ± ** | ç¼–è¯‘æœŸå­—ç¬¦ä¸²ï¼Œæ— æ³•æ¸…ç©º |
| **è‡ªå®šä¹‰æ± ** | è¿è¡ŒæœŸå­—ç¬¦ä¸²ï¼Œå¯æŒ‰éœ€æ¸…ç©º |

### 15.3 å­—ç¬¦ä¸²åˆ†ç±»å¤„ç†

| ç±»å‹ | ç¤ºä¾‹ | ç¼“å­˜ç­–ç•¥ |
|-----|------|---------|
| **æ•´æ•°å‹** | "12s" | å¸¸é©»æ±  |
| **å›ºå®šæ‹¼æ¥** | "gun_ak47" | å¸¸é©»æ±  |
| **åŠ¨æ€å†…å®¹** | "å¼ ä¸‰å‡»æ€äº†æå››" | æˆ˜æ–—æ±  |

---

## åå…­ã€åŒ¿åæ–¹æ³•

### 16.1 GC Alloc åœºæ™¯

```csharp
// âŒ æ¯æ¬¡è°ƒç”¨ç”Ÿæˆæ–°å¯¹è±¡
void Func()
{
    int a = 1;
    Call(() => a = 2);  // æ•è·å±€éƒ¨å˜é‡
}

// âœ… ä½¿ç”¨é™æ€å˜é‡
static int a = 1;
void Func()
{
    Call(() => a = 2);  // Mono ä¸­æ—  GC Alloc
}

// âœ… ç¼“å­˜å§”æ‰˜
int a = 1;
Action action;
void Func()
{
    if (action == null)
        action = () => a = 2;
    Call(action);
}
```

> âš ï¸ **æ³¨æ„**ï¼šIL2CPP ä¸­æ‰€æœ‰åŒ¿åå½¢å¼éƒ½ä¼šäº§ç”Ÿ GC Allocï¼

---

## åä¸ƒã€åç¨‹ä¼˜åŒ–

### 17.1 WaitForSeconds ç¼“å­˜

```csharp
// âŒ æ¯æ¬¡åˆ›å»ºæ–°å¯¹è±¡
yield return new WaitForSeconds(5);

// âœ… ç¼“å­˜ WaitForSeconds
static readonly WaitForSeconds fiveSeconds = new WaitForSeconds(5);
yield return fiveSeconds;
```

### 17.2 è‡ªå®šä¹‰ IEnumerator

```csharp
// âœ… æ‰‹åŠ¨å®ç°å¯ç¼“å­˜çš„ IEnumerator
class Coroutine1 : IEnumerator
{
    public bool MoveNext() { ... }
    public void Reset() { ... }
    public object Current { get { ... } }
}

// ä½¿ç”¨æ—¶
Coroutine1 coroutine1 = new Coroutine1();
while (true)
{
    yield return coroutine1;
    coroutine1.Reset();  // æ‰‹åŠ¨é‡ç½®
}
```

---

## åå…«ã€Unity API ä¼˜åŒ–

### 18.1 é¿å…çš„ API

| API | é—®é¢˜ | æ›¿ä»£æ–¹æ¡ˆ |
|-----|------|---------|
| `object.name` | äº§ç”Ÿ GC | ç¼“å­˜åå­— |
| `object.tag` | äº§ç”Ÿ GC | `CompareTag()` |
| è¿”å›æ•°ç»„çš„ API | äº§ç”Ÿæ–°æ•°ç»„ | ä½¿ç”¨ List ç‰ˆæœ¬ |

### 18.2 List æ¨¡å¼

```csharp
// âœ… ä½¿ç”¨ ListPool + List å‚æ•° API
List<Text> texts = ListPool<Text>.Get();
GetComponentsInChildren(texts);
// ... ä½¿ç”¨ texts ...
ListPool<Text>.Release(texts);
```

### 18.3 NavMesh ä¼˜åŒ–

```csharp
// âœ… ä½¿ç”¨ NonAlloc ç‰ˆæœ¬
public static Vector3[] cachedPath = new Vector3[256];
public static int pathCount { get; private set; }
private static NavMeshPath navMeshPath;

public static void CalculatePath(Vector3 startPos, Vector3 endPos)
{
    navMeshPath.ClearCorners();
    NavMesh.CalculatePath(startPos, endPos, NavMesh.AllAreas, navMeshPath);
    pathCount = navMeshPath.GetCornersNonAlloc(cachedPath);
}
```

### 18.4 ç‰©ç† NonAlloc

```csharp
// âœ… ä½¿ç”¨ NonAlloc ç‰ˆæœ¬
RaycastHit[] hits = new RaycastHit[10];
int hitCount = Physics.RaycastNonAlloc(ray, hits);
```

---

## åä¹ã€Protobuf ä¼˜åŒ–

### 19.1 é¿å…æµå¤åˆ¶

```csharp
// âŒ ä¼ å…¥ Stream ä¼šå¤åˆ¶å­—èŠ‚æµ
message.MergeFrom(stream);

// âœ… ç›´æ¥ä½¿ç”¨ byte[]
message.MergeFrom(cachedBytes);
```

### 19.2 æ¶ˆæ¯å¯¹è±¡æ± 

```csharp
public class NetMsgInStream
{
    public CodedInputStream codedStream { get; private set; }
    public MemoryStream memoryStream { get; } = new MemoryStream();

    public NetMsgInStream()
    {
        this.codedStream = new CodedInputStream(memoryStream);
    }

    public static ObjectPool<NetMsgInStream> pool =
        new ObjectPool(actionOnRelease: (s) => s.memoryStream.SetLength(0));
}

// ä½¿ç”¨
var stream = NetMsgInStream.pool.Get();
message.MergeFrom(stream.codedStream);
NetMsgInStream.pool.Release(stream);
```

---

## äºŒåã€Unsafe ä¼˜åŒ–

### 20.1 å­—ç¬¦ä¸² ToLower

```csharp
// âœ… Unsafe ç‰ˆæœ¬ ToLower
public static void ToLower(string str)
{
    fixed (char* c = str)
    {
        int length = str.Length;
        for (int i = 0; i < length; ++i)
        {
            c[i] = char.ToLower(c[i]);
        }
    }
}
```

### 20.2 å­—ç¬¦ä¸² Split

```csharp
// âœ… Unsafe ç‰ˆæœ¬ Split
public static int Split(string str, char split, string[] toFill)
{
    if (str.Length == 0)
    {
        toFill[0] = string.Empty;
        return 1;
    }

    fixed (char* p = str)
    {
        var start = 0;
        int ret = 0;
        for (int i = 0; i < str.Length; ++i)
        {
            if (p[i] == split)
            {
                toFill[ret++] = new string(p, start, i - start);
                start = i + 1;
            }
        }
        if (start < str.Length)
        {
            toFill[ret++] = new string(p, start, str.Length - start);
        }
        return ret;
    }
}
```

### 20.3 ä¿®æ”¹å­—ç¬¦ä¸²é•¿åº¦

```csharp
// âš ï¸ å±é™©æ“ä½œï¼šä¿®æ”¹å­—ç¬¦ä¸²é•¿åº¦
public static void SetLength(this string str, int length)
{
    fixed (char* s = str)
    {
        int* ptr = (int*)s;
        ptr[-1] = length;        // ä¿®æ”¹é•¿åº¦
        s[length] = '\0';        // æ·»åŠ ç»ˆæ­¢ç¬¦
    }
}
```

---

## äºŒåä¸€ã€éæ‰˜ç®¡å †

### 21.1 UnsafeList å®ç°

```csharp
public unsafe struct UnsafeList<T> where T : unmanaged
{
    static int alignment = UnsafeUtility.AlignOf<T>();
    static int elementSize = UnsafeUtility.SizeOf<T>();
    const int MIN_SIZE = 4;
    ArrayInfo* array;

    public UnsafeList(int capacity)
    {
        capacity = Mathf.Max(MIN_SIZE, capacity);
        array = (ArrayInfo*)UnsafeUtility.Malloc(
            UnsafeUtility.SizeOf<ArrayInfo>(),
            UnsafeUtility.AlignOf<ArrayInfo>(),
            Allocator.Persistent);
        array->capacity = capacity;
        array->count = 0;
        array->ptr = UnsafeUtility.Malloc(
            elementSize * capacity,
            alignment,
            Allocator.Persistent);
    }

    public void Dispose()
    {
        UnsafeUtility.Free(array->ptr, Allocator.Persistent);
        UnsafeUtility.Free(array, Allocator.Persistent);
    }

    public void Add(T t)
    {
        EnsureCapacity(array->count + 1);
        *((T*)array->ptr + array->count) = t;
        ++array->count;
    }
}

unsafe struct ArrayInfo
{
    public int count;
    public int capacity;
    public void* ptr;
}
```

### 21.2 Allocator ç±»å‹

| Allocator | ç”Ÿå‘½å‘¨æœŸ | æ€§èƒ½ | ç”¨é€” |
|-----------|---------|------|------|
| **Temp** | ä¸€å¸§ | å¿« | ä¸´æ—¶æ•°æ® |
| **TempJob** | 4å¸§ | è¾ƒå¿« | Job System |
| **Persistent** | æ‰‹åŠ¨é‡Šæ”¾ | è¾ƒæ…¢ | é•¿æœŸæ•°æ® |

---

## äºŒåäºŒã€stackalloc ä¸ Span

### 22.1 stackalloc

```csharp
// âœ… æ ˆä¸Šå¿«é€Ÿåˆ†é…
void Calculate()
{
    Vector3* s = stackalloc Vector3[10];
    // ä½œç”¨åŸŸç»“æŸè‡ªåŠ¨é‡Šæ”¾
}
```

### 22.2 Span vs Memory

| ç±»å‹ | ç‰¹æ€§ | é™åˆ¶ |
|-----|------|------|
| **Span\<T\>** | ref structï¼Œä¸èƒ½ä½œå­—æ®µ | ä¸èƒ½è·¨è¶Š yield/await |
| **Memory\<T\>** | å¯ä½œå­—æ®µ | éœ€è¦è½¬æ¢ |

```csharp
// âœ… Span æ“ä½œæ‰˜ç®¡/éæ‰˜ç®¡/æ ˆå†…å­˜
Span<int> stackSpan = stackalloc int[10];
Span<int> managedSpan = new int[10].AsSpan();
```

---

## äºŒåä¸‰ã€ä¼˜åŒ–æ€»ç»“

### 23.1 å¿«é€Ÿæ£€æŸ¥æ¸…å•

| æ£€æŸ¥é¡¹ | è¯´æ˜ |
|-------|------|
| âœ… **ç¼“å­˜ç»„ä»¶** | ç¼“å­˜ GetComponent ç»“æœ |
| âœ… **é¿å… string** | ä½¿ç”¨ StringBuilder æˆ–ç¼“å­˜ |
| âœ… **é¿å…è£…ç®±** | ä½¿ç”¨æ³›å‹ã€é¿å… object å‚æ•° |
| âœ… **å¯¹è±¡æ± ** | å¤ç”¨é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡ |
| âœ… **é¢„åˆ†é…å®¹å™¨** | è®¾ç½® List/Dictionary åˆå§‹å®¹é‡ |
| âœ… **ä½¿ç”¨ NonAlloc API** | é¿å…æ•°ç»„åˆ†é… |
| âœ… **ç¼“å­˜ WaitForSeconds** | é™æ€åªè¯»å­—æ®µ |
| âœ… **é¿å…åŒ¿åæ–¹æ³•** | IL2CPP ä¼šäº§ç”Ÿ GC |

### 23.2 å·¥å…·æ¨è

| å·¥å…· | ç”¨é€” |
|-----|------|
| **Unity Profiler** | æŸ¥çœ‹ GC Alloc |
| **Deep Profiler** | è¯¦ç»†è°ƒç”¨å †æ ˆ |
| **Memory Profiler** | å†…å­˜å¿«ç…§å¯¹æ¯” |

---

## äºŒåå››ã€å‚è€ƒèµ„æ–™

- [Unity - Manual: Optimizing Scripts](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)
- [C# - Writing safe and efficient C# code](https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code)
- [Unity Blog - Optimizing garbage collection in Unity games](https://blog.unity.com/technology/optimizing-garbage-collection-in-unity-games)

---

**è½¬è½½è¯·æ³¨æ˜æ¥æº**ï¼Œæ¬¢è¿å¯¹æ–‡ç« ä¸­çš„å¼•ç”¨æ¥æºè¿›è¡Œè€ƒè¯ï¼Œæ¬¢è¿æŒ‡å‡ºä»»ä½•æœ‰é”™è¯¯æˆ–ä¸å¤Ÿæ¸…æ™°çš„è¡¨è¾¾ã€‚å¯ä»¥åœ¨ä¸‹é¢è¯„è®ºåŒºè¯„è®ºï¼Œä¹Ÿå¯ä»¥é‚®ä»¶è‡³ 1487842110@qq.com
